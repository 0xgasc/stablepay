<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#FFFFFF">
    <title data-i18n="title">Crypto Payment - StablePay</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Space Grotesk', sans-serif;
        }
        body {
            background: #FFFFFF;
            font-family: 'Space Grotesk', sans-serif;
        }
        body.night-mode {
            background: #1a1a1a;
            color: #fff;
        }
        body.night-mode .bg-white {
            background: #000 !important;
        }
        body.night-mode .text-black {
            color: #fff !important;
        }

        body.night-mode header .text-black,
        body.night-mode nav .text-black,
        body.night-mode header a,
        body.night-mode nav a,
        body.night-mode header span,
        body.night-mode nav span {
            color: #fff !important;
        }
        body.night-mode select,
        body.night-mode option {
            background: #000 !important;
            color: #fff !important;
            border-color: #fff !important;
        }
        body.night-mode .text-gray-700 {
            color: #ccc !important;
        }
        body.night-mode .text-gray-400 {
            color: #999 !important;
        }
        body.night-mode .text-gray-500 {
            color: #888 !important;
        }
        body.night-mode .brutal-border,
        body.night-mode .border-black {
            border-color: #fff !important;
        }
        body.night-mode .border-gray-300 {
            border-color: #666 !important;
        }
        body.night-mode [style*="box-shadow"][style*="#000"] {
            box-shadow: 8px 8px 0px #fff !important;
        }
        body.night-mode .shadow-brutal {
            box-shadow: 8px 8px 0px #fff !important;
        }
        .brutal-border {
            border: 4px solid #000;
        }
        .shadow-brutal {
            box-shadow: 8px 8px 0px #000;
        }
        .btn-brutal {
            border: 4px solid #000;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.05em;
            transition: all 0.2s;
        }
        .btn-brutal:hover {
            transform: translate(4px, 4px);
            box-shadow: 4px 4px 0px #000;
        }
        body.night-mode .btn-brutal {
            border-color: #fff;
        }
        body.night-mode .btn-brutal:hover {
            box-shadow: 4px 4px 0px #fff;
        }
        /* Wallet modal night mode */
        body.night-mode #walletModal > div:nth-child(2) {
            background: #1a1a1a !important;
            border-color: #fff !important;
        }
        body.night-mode #walletModal h3,
        body.night-mode #walletModal button span {
            color: #fff !important;
        }
        body.night-mode #walletModal button {
            border-color: #fff !important;
        }
        body.night-mode #walletModal button:hover {
            background: #333 !important;
        }
        /* Success screen night mode */
        body.night-mode #paymentSuccessScreen {
            background: #1a1a1a !important;
            border-color: #fff !important;
        }
        body.night-mode #paymentSuccessScreen h2,
        body.night-mode #paymentSuccessScreen span {
            color: #fff !important;
        }
        body.night-mode #paymentSuccessScreen .border-4 {
            border-color: #fff !important;
        }
        input, select {
            border: 4px solid #000;
            border-radius: 0;
        }
        body.night-mode input,
        body.night-mode select {
            border-color: #fff;
            background: #000;
            color: #fff;
        }
        .testnet-badge {
            background: #FFA500;
            color: #000;
            border-bottom: 4px solid #000;
        }
        body.night-mode .testnet-badge {
            background: #FF8C00;
            color: #fff;
            border-color: #fff;
        }

        /* ===== MOBILE OPTIMIZATIONS ===== */

        /* Safe area padding for notched devices (iPhone X+) */
        body {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* Prevent iOS zoom on input focus - minimum 16px */
        input, select, textarea {
            font-size: 16px !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Touch-friendly button sizes (minimum 44px) */
        .btn-brutal, button, .touch-target {
            min-height: 48px;
            min-width: 48px;
        }

        /* Better touch feedback */
        .btn-brutal:active, button:active {
            transform: translate(2px, 2px);
            opacity: 0.9;
        }

        /* Remove tap highlight on mobile */
        * {
            -webkit-tap-highlight-color: transparent;
        }

        /* Smooth scrolling for iOS */
        html {
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }

        /* Fix for iOS input shadows */
        input, textarea {
            -webkit-appearance: none;
            box-shadow: none;
        }

        /* Mobile modal improvements */
        @media (max-width: 640px) {
            /* Adjust shadow for smaller screens */
            .shadow-brutal {
                box-shadow: 4px 4px 0px #000;
            }
            body.night-mode .shadow-brutal {
                box-shadow: 4px 4px 0px #fff !important;
            }

            /* Larger touch targets on mobile */
            .btn-brutal {
                padding: 16px 20px;
                font-size: 14px;
            }

            /* Better header sizing */
            nav .text-3xl {
                font-size: 1.25rem;
            }

            /* Full-width modal on mobile */
            #walletModal > div:nth-child(2) {
                margin: 16px;
                max-height: calc(100vh - 32px);
                overflow-y: auto;
            }

            /* Larger wallet options for touch */
            #walletOptions button {
                padding: 16px;
                min-height: 64px;
            }

            /* Stack success buttons on mobile */
            #paymentSuccessScreen .flex.gap-4 {
                flex-direction: column;
            }

            /* Adjust heading sizes */
            h1.text-4xl {
                font-size: 1.75rem;
            }
            h2.text-3xl {
                font-size: 1.5rem;
            }
            h2.text-2xl {
                font-size: 1.25rem;
            }

            /* Better spacing for cards */
            .border-4 {
                border-width: 3px;
            }

            /* Adjust container padding */
            .container {
                padding-left: 12px;
                padding-right: 12px;
            }
        }

        /* Extra small devices (iPhone SE, etc.) */
        @media (max-width: 375px) {
            nav .text-3xl {
                font-size: 1.1rem;
            }

            h1.text-4xl {
                font-size: 1.5rem;
            }

            .btn-brutal {
                padding: 12px 16px;
                font-size: 13px;
            }

            #languageSelector, #nightModeToggle {
                padding: 8px 12px;
                font-size: 12px;
            }
        }

        /* Tablet (iPad) optimizations */
        @media (min-width: 768px) and (max-width: 1024px) {
            .container {
                max-width: 600px;
            }
        }

        /* Landscape mode on phones */
        @media (max-height: 500px) and (orientation: landscape) {
            .container {
                padding-top: 8px;
                padding-bottom: 8px;
            }

            #walletModal > div:nth-child(2) {
                max-height: 90vh;
                margin: 8px;
            }
        }

        /* Loading state animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Mobile wallet deep link button */
        .mobile-wallet-link {
            display: none;
        }
        @media (max-width: 768px) {
            .mobile-wallet-link {
                display: block;
            }
        }
    </style>
</head>
<body class="min-h-screen">
    <!-- Testnet Banner -->
    <div class="testnet-badge text-center py-3 text-sm font-bold tracking-wide" style="text-transform: uppercase;">
        <span data-i18n="banner">TESTNET MODE - USING BASE SEPOLIA & ETHEREUM SEPOLIA</span>
    </div>

    <!-- Navigation -->
    <nav class="bg-white border-b-4 border-black">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-20">
                <a href="/" class="text-3xl font-bold tracking-tight text-black" style="text-transform: uppercase;">
                    STABLEPAY
                </a>
                <div class="flex items-center gap-4">
                    <!-- Language Selector -->
                    <select id="languageSelector" class="px-3 py-2 bg-white text-black font-bold text-sm">
                        <option value="en">EN</option>
                        <option value="es">ES</option>
                        <option value="fr">FR</option>
                        <option value="pt">PT</option>
                    </select>
                    <!-- Night Mode Toggle -->
                    <button id="nightModeToggle" class="px-4 py-2 bg-white text-black font-bold text-sm btn-brutal">
                        <span class="night-icon" data-i18n="nav.night">NIGHT</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 py-8 max-w-2xl">
        <!-- Back Button -->
        <div class="mb-6">
            <button id="backBtn" class="text-black font-bold flex items-center tracking-wide btn-brutal px-4 py-2" style="text-transform: uppercase; background: #00E5FF;" data-i18n="backBtn">
                BACK TO STORE
            </button>
        </div>

        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-3 text-black tracking-tight" style="text-transform: uppercase;" data-i18n="heading">COMPLETE YOUR PURCHASE</h1>
            <p class="text-gray-700" data-i18n="subheading">Pay with USDC on testnet</p>
        </div>

        <!-- Product Summary -->
        <div id="productSummary" class="bg-white border-4 border-black p-6 shadow-brutal mb-6">
            <h2 class="text-2xl font-bold mb-4 text-black tracking-wide" style="text-transform: uppercase;" data-i18n="summary.heading">ORDER SUMMARY</h2>
            <div class="space-y-4">
                <div class="flex justify-between pb-3 border-b-4 border-black">
                    <span class="text-gray-700 font-bold tracking-wide" style="text-transform: uppercase;" data-i18n="summary.product">PRODUCT</span>
                    <span id="productName" class="text-black font-bold">Loading...</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-700 font-bold tracking-wide" style="text-transform: uppercase;" data-i18n="summary.amount">AMOUNT</span>
                    <span id="productPrice" class="text-black font-bold" style="color: #00E5FF;">Loading...</span>
                </div>
            </div>
        </div>

        <!-- Wallet Connection -->
        <div id="walletSection" class="bg-white border-4 border-black p-6 shadow-brutal mb-6">
            <div id="connectWalletBtn" class="text-center">
                <button id="connectBtn" class="w-full px-6 py-4 font-bold tracking-wide btn-brutal text-black" style="text-transform: uppercase; background: #4FC3F7;" data-i18n="wallet.connect">
                    CONNECT WALLET
                </button>
            </div>
            <div id="walletInfo" class="hidden">
                <div class="flex justify-between items-center pb-4 border-b-4 border-black">
                    <div>
                        <p class="text-sm text-gray-700 font-bold tracking-wide" style="text-transform: uppercase;" data-i18n="wallet.connected">CONNECTED WALLET</p>
                        <p class="font-mono text-sm text-black font-bold" id="walletAddress"></p>
                    </div>
                    <button id="disconnectBtn" class="px-3 py-2 font-bold text-sm btn-brutal text-black" style="background: #FF6B6B; text-transform: uppercase;" data-i18n="wallet.disconnect">
                        DISCONNECT
                    </button>
                </div>
                <div class="mt-4 pt-4">
                    <p class="text-sm text-gray-700 font-bold tracking-wide mb-3" style="text-transform: uppercase;" data-i18n="wallet.balances">USDC BALANCE ON ALL CHAINS</p>
                    <div id="usdcBalances" class="space-y-2">
                        <div class="flex justify-between border-4 border-black p-3">
                            <span class="text-sm font-bold text-black" data-i18n="wallet.baseSepolia">BASE SEPOLIA:</span>
                            <span id="baseSepBalance" class="text-sm font-mono font-bold text-black">Loading...</span>
                        </div>
                        <div class="flex justify-between border-4 border-black p-3">
                            <span class="text-sm font-bold text-black" data-i18n="wallet.ethSepolia">ETHEREUM SEPOLIA:</span>
                            <span id="ethSepBalance" class="text-sm font-mono font-bold text-black">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Customer Information -->
        <div id="customerSection" class="hidden bg-white border-4 border-black p-6 shadow-brutal mb-6">
            <h2 class="text-2xl font-bold mb-4 text-black tracking-wide" style="text-transform: uppercase;" data-i18n="customer.heading">CUSTOMER INFORMATION</h2>
            <div class="space-y-4">
                <div>
                    <label for="customerEmail" class="block text-sm font-bold text-black mb-2 tracking-wide" style="text-transform: uppercase;" data-i18n="customer.email">
                        EMAIL ADDRESS *
                    </label>
                    <input
                        type="email"
                        id="customerEmail"
                        placeholder="your@email.com"
                        class="w-full px-4 py-3 bg-white text-black focus:outline-none"
                        required
                    />
                    <p class="text-xs text-gray-500 mt-2" data-i18n="customer.emailHint">We'll send your receipt to this address</p>
                </div>
                <div>
                    <label for="customerName" class="block text-sm font-bold text-black mb-2 tracking-wide" style="text-transform: uppercase;" data-i18n="customer.name">
                        FULL NAME (OPTIONAL)
                    </label>
                    <input
                        type="text"
                        id="customerName"
                        placeholder="John Doe"
                        class="w-full px-4 py-3 bg-white text-black focus:outline-none"
                    />
                </div>
            </div>
        </div>

        <!-- Chain Selection & Payment -->
        <div id="paymentSection" class="hidden bg-white border-4 border-black p-6 shadow-brutal mb-6">
            <h2 class="text-2xl font-bold mb-4 text-black tracking-wide" style="text-transform: uppercase;" data-i18n="payment.heading">SELECT PAYMENT CHAIN</h2>

            <!-- Dynamic chain options - populated based on merchant's configured wallets -->
            <div id="chainOptions" class="space-y-4 mb-6">
                <div class="text-center py-4 text-gray-500">
                    <span class="animate-pulse">Loading available chains...</span>
                </div>
            </div>

            <button
                id="payBtn"
                class="w-full px-6 py-4 font-bold tracking-wide btn-brutal text-black disabled:opacity-50 disabled:cursor-not-allowed"
                style="text-transform: uppercase; background: #00E5FF;"
                disabled
                data-i18n="payment.payBtn"
            >
                PAY WITH USDC
            </button>

            <div id="txStatus" class="hidden mt-4 p-4 border-4 border-black" style="background: #E3F2FD;">
                <p class="text-sm font-bold mb-2 text-black tracking-wide" style="text-transform: uppercase;" data-i18n="payment.txStatus">TRANSACTION STATUS</p>
                <p id="txMessage" class="text-sm text-black font-bold"></p>
                <a id="txLink" href="#" target="_blank" class="text-black font-bold text-sm mt-2 inline-block hidden underline" data-i18n="payment.viewExplorer">
                    VIEW ON EXPLORER
                </a>
            </div>
        </div>

        <!-- Error/Success Messages -->
        <div id="errorMessage" class="hidden border-4 border-black p-4 mb-6" style="background: #FFE5E5;">
            <p class="text-black font-bold"></p>
        </div>

        <div id="successMessage" class="hidden border-4 border-black p-4 mb-6" style="background: #E5FFE5;">
            <p class="text-black font-bold"></p>
        </div>

        <!-- Payment Success Screen (shown after successful payment) -->
        <div id="paymentSuccessScreen" class="hidden bg-white border-4 border-black p-8 shadow-brutal text-center">
            <div class="text-6xl mb-4">âœ…</div>
            <h2 class="text-3xl font-bold text-black mb-2" style="text-transform: uppercase;">PAYMENT SUCCESSFUL!</h2>
            <p class="text-gray-700 mb-6">Your transaction has been confirmed on the blockchain.</p>

            <div class="border-4 border-black p-4 mb-6 text-left" style="background: #F0FFF0;">
                <div class="flex justify-between mb-2">
                    <span class="text-gray-700 font-bold">Product:</span>
                    <span id="successProductName" class="text-black font-bold">-</span>
                </div>
                <div class="flex justify-between mb-2">
                    <span class="text-gray-700 font-bold">Amount:</span>
                    <span id="successAmount" class="text-black font-bold">-</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-700 font-bold">Network:</span>
                    <span id="successChain" class="text-black font-bold">-</span>
                </div>
            </div>

            <a id="successTxLink" href="#" target="_blank"
               class="block w-full px-6 py-4 font-bold tracking-wide btn-brutal text-black mb-4"
               style="text-transform: uppercase; background: #E3F2FD; text-decoration: none;">
                VIEW TRANSACTION ON EXPLORER â†’
            </a>

            <div class="flex gap-4">
                <button onclick="buyAgain()"
                        class="flex-1 px-6 py-4 font-bold tracking-wide btn-brutal text-black"
                        style="text-transform: uppercase; background: #00E5FF;">
                    BUY AGAIN
                </button>
                <button onclick="goBack()"
                        class="flex-1 px-6 py-4 font-bold tracking-wide btn-brutal text-black"
                        style="text-transform: uppercase; background: #FFF;">
                    BACK TO STORE
                </button>
            </div>
        </div>
    </div>

    <!-- Wallet Selection Modal -->
    <div id="walletModal" class="hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black bg-opacity-50" onclick="closeWalletModal()"></div>
        <div class="relative bg-white border-4 border-black shadow-brutal p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-bold text-black tracking-wide" style="text-transform: uppercase;">SELECT WALLET</h3>
                <button onclick="closeWalletModal()" class="text-black font-bold text-2xl hover:text-gray-600">&times;</button>
            </div>
            <div id="walletOptions" class="space-y-3">
                <!-- Wallet options will be populated by JS -->
            </div>
            <p class="text-xs text-gray-500 mt-4 text-center">Don't have a wallet? <a href="https://metamask.io/download/" target="_blank" class="underline font-bold">Get MetaMask</a></p>
        </div>
    </div>

    <script>
        // All supported chain configurations
        const CHAIN_CONFIG = {
            // Testnets
            BASE_SEPOLIA: {
                chainId: '0x14a34', // 84532
                chainName: 'Base Sepolia',
                rpcUrls: ['https://sepolia.base.org'],
                blockExplorerUrls: ['https://sepolia.basescan.org'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                usdcAddress: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',
                network: 'testnet',
                description: 'Base testnet - Lower fees'
            },
            ETHEREUM_SEPOLIA: {
                chainId: '0xaa36a7', // 11155111
                chainName: 'Ethereum Sepolia',
                rpcUrls: ['https://eth-sepolia.g.alchemy.com/v2/demo'],
                blockExplorerUrls: ['https://sepolia.etherscan.io'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                usdcAddress: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238',
                network: 'testnet',
                description: 'Ethereum testnet'
            },
            POLYGON_MUMBAI: {
                chainId: '0x13882', // 80002
                chainName: 'Polygon Amoy',
                rpcUrls: ['https://rpc-amoy.polygon.technology'],
                blockExplorerUrls: ['https://amoy.polygonscan.com'],
                nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
                usdcAddress: '0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582',
                network: 'testnet',
                description: 'Polygon testnet'
            },
            ARBITRUM_SEPOLIA: {
                chainId: '0x66eee', // 421614
                chainName: 'Arbitrum Sepolia',
                rpcUrls: ['https://sepolia-rollup.arbitrum.io/rpc'],
                blockExplorerUrls: ['https://sepolia.arbiscan.io'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                usdcAddress: '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d',
                network: 'testnet',
                description: 'Arbitrum testnet'
            },
            // Mainnets
            BASE_MAINNET: {
                chainId: '0x2105', // 8453
                chainName: 'Base',
                rpcUrls: ['https://mainnet.base.org'],
                blockExplorerUrls: ['https://basescan.org'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                usdcAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
                network: 'mainnet',
                description: 'Base - Recommended, low fees'
            },
            ETHEREUM_MAINNET: {
                chainId: '0x1', // 1
                chainName: 'Ethereum',
                rpcUrls: ['https://eth.llamarpc.com'],
                blockExplorerUrls: ['https://etherscan.io'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                usdcAddress: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
                network: 'mainnet',
                description: 'Ethereum mainnet'
            },
            POLYGON_MAINNET: {
                chainId: '0x89', // 137
                chainName: 'Polygon',
                rpcUrls: ['https://polygon-rpc.com'],
                blockExplorerUrls: ['https://polygonscan.com'],
                nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
                usdcAddress: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359',
                network: 'mainnet',
                description: 'Polygon - Fast & cheap'
            },
            ARBITRUM_MAINNET: {
                chainId: '0xa4b1', // 42161
                chainName: 'Arbitrum One',
                rpcUrls: ['https://arb1.arbitrum.io/rpc'],
                blockExplorerUrls: ['https://arbiscan.io'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                usdcAddress: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',
                network: 'mainnet',
                description: 'Arbitrum L2'
            }
        };

        // Merchant's enabled chains (populated on load)
        let merchantChains = [];

        // USDC ABI (minimal)
        const USDC_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function transfer(address to, uint256 amount) returns (bool)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)"
        ];

        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let currentProduct = null;
        let selectedWalletProvider = null;

        // Detect available wallets
        function detectWallets() {
            const wallets = [];

            // Check for MetaMask (has isMetaMask flag)
            if (window.ethereum?.isMetaMask && !window.ethereum?.isPhantom) {
                wallets.push({
                    name: 'MetaMask',
                    icon: 'ðŸ¦Š',
                    provider: window.ethereum,
                    rdns: 'io.metamask'
                });
            }

            // Check for Phantom
            if (window.phantom?.ethereum || window.ethereum?.isPhantom) {
                wallets.push({
                    name: 'Phantom',
                    icon: 'ðŸ‘»',
                    provider: window.phantom?.ethereum || window.ethereum,
                    rdns: 'app.phantom'
                });
            }

            // Check for Coinbase Wallet
            if (window.ethereum?.isCoinbaseWallet || window.coinbaseWalletExtension) {
                wallets.push({
                    name: 'Coinbase Wallet',
                    icon: 'ðŸ”µ',
                    provider: window.coinbaseWalletExtension || window.ethereum,
                    rdns: 'com.coinbase.wallet'
                });
            }

            // Check for Trust Wallet
            if (window.ethereum?.isTrust || window.trustwallet) {
                wallets.push({
                    name: 'Trust Wallet',
                    icon: 'ðŸ›¡ï¸',
                    provider: window.trustwallet?.ethereum || window.ethereum,
                    rdns: 'com.trustwallet.app'
                });
            }

            // Check for Rabby
            if (window.ethereum?.isRabby) {
                wallets.push({
                    name: 'Rabby',
                    icon: 'ðŸ°',
                    provider: window.ethereum,
                    rdns: 'io.rabby'
                });
            }

            // Use EIP-6963 if available (modern wallet detection)
            if (window.ethereum?.providers?.length > 0) {
                window.ethereum.providers.forEach(p => {
                    if (p.isMetaMask && !wallets.find(w => w.rdns === 'io.metamask')) {
                        wallets.push({ name: 'MetaMask', icon: 'ðŸ¦Š', provider: p, rdns: 'io.metamask' });
                    }
                    if (p.isPhantom && !wallets.find(w => w.rdns === 'app.phantom')) {
                        wallets.push({ name: 'Phantom', icon: 'ðŸ‘»', provider: p, rdns: 'app.phantom' });
                    }
                    if (p.isCoinbaseWallet && !wallets.find(w => w.rdns === 'com.coinbase.wallet')) {
                        wallets.push({ name: 'Coinbase Wallet', icon: 'ðŸ”µ', provider: p, rdns: 'com.coinbase.wallet' });
                    }
                });
            }

            // Fallback: if no specific wallet detected but ethereum exists
            if (wallets.length === 0 && window.ethereum) {
                wallets.push({
                    name: 'Browser Wallet',
                    icon: 'ðŸ”—',
                    provider: window.ethereum,
                    rdns: 'unknown'
                });
            }

            return wallets;
        }

        // Show wallet selection modal
        function showWalletModal() {
            const wallets = detectWallets();
            const walletOptionsDiv = document.getElementById('walletOptions');

            if (wallets.length === 0) {
                walletOptionsDiv.innerHTML = `
                    <div class="text-center p-4">
                        <p class="text-black font-bold mb-4">No wallets detected</p>
                        <a href="https://metamask.io/download/" target="_blank"
                           class="inline-block px-6 py-3 btn-brutal text-black"
                           style="background: #4FC3F7; text-transform: uppercase;">
                            Install MetaMask
                        </a>
                    </div>
                `;
            } else {
                walletOptionsDiv.innerHTML = wallets.map(wallet => `
                    <button onclick="connectWithWallet('${wallet.rdns}')"
                            class="w-full flex items-center gap-4 p-4 border-4 border-black hover:bg-gray-100 transition">
                        <span class="text-3xl">${wallet.icon}</span>
                        <span class="font-bold text-black text-lg">${wallet.name}</span>
                    </button>
                `).join('');
            }

            document.getElementById('walletModal').classList.remove('hidden');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.add('hidden');
        }

        // Connect with specific wallet
        async function connectWithWallet(rdns) {
            const wallets = detectWallets();
            const wallet = wallets.find(w => w.rdns === rdns);

            if (!wallet) {
                showError('Wallet not found');
                return;
            }

            closeWalletModal();
            selectedWalletProvider = wallet.provider;

            try {
                console.log(`Connecting with ${wallet.name}...`);

                const accounts = await wallet.provider.request({
                    method: 'eth_requestAccounts'
                });

                if (!accounts || accounts.length === 0) {
                    showError('No accounts found. Please unlock your wallet.');
                    return;
                }

                provider = new ethers.BrowserProvider(wallet.provider);
                signer = await provider.getSigner();
                connectedAddress = await signer.getAddress();
                console.log('Connected address:', connectedAddress);

                // Update UI
                document.getElementById('connectWalletBtn').classList.add('hidden');
                document.getElementById('walletInfo').classList.remove('hidden');
                document.getElementById('customerSection').classList.remove('hidden');
                document.getElementById('paymentSection').classList.remove('hidden');
                document.getElementById('walletAddress').textContent =
                    connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);

                // Get USDC balance
                await updateUSDCBalance();

                showSuccess(`Connected with ${wallet.name}!`);
            } catch (error) {
                console.error('Connection error:', error);
                if (error.code === 4001) {
                    showError('Connection rejected. Please try again.');
                } else {
                    showError('Failed to connect: ' + error.message);
                }
            }
        }

        // Parse URL parameters to get product info
        async function loadProductInfo() {
            const urlParams = new URLSearchParams(window.location.search);
            currentProduct = {
                id: urlParams.get('productId'),
                name: urlParams.get('productName'),
                price: parseFloat(urlParams.get('price')),
                merchantId: urlParams.get('merchantId') || null,
                enabledChains: urlParams.get('chains') ? urlParams.get('chains').split(',') : null // Specific chains to show
            };

            if (!currentProduct.id || !currentProduct.name || !currentProduct.price) {
                showError('Invalid product data. Please start from the store.');
                setTimeout(() => goBack(), 3000);
                return;
            }

            // Update UI with product info
            document.getElementById('productName').textContent = currentProduct.name;
            document.getElementById('productPrice').textContent = `$${currentProduct.price} (${currentProduct.price} USDC)`;

            console.log('Product loaded:', currentProduct);
            if (currentProduct.enabledChains) {
                console.log('Enabled chains from URL:', currentProduct.enabledChains);
            }

            // Fetch merchant's enabled chains
            await loadMerchantChains();
        }

        // Fetch merchant's configured wallets and render chain options
        async function loadMerchantChains() {
            const chainOptionsContainer = document.getElementById('chainOptions');

            if (!currentProduct.merchantId) {
                // No merchant ID - show default testnet chains
                console.log('No merchant ID, showing default testnet chains');
                let defaultChains = Object.keys(CHAIN_CONFIG)
                    .filter(key => CHAIN_CONFIG[key].network === 'testnet');

                // Filter by URL param if provided
                if (currentProduct.enabledChains) {
                    defaultChains = defaultChains.filter(key => currentProduct.enabledChains.includes(key));
                }

                merchantChains = defaultChains.map(key => ({ chain: key, address: null }));
                renderChainOptions();
                return;
            }

            try {
                console.log('Fetching merchant wallets for:', currentProduct.merchantId);
                const response = await fetch(`/api/merchant-profile?id=${currentProduct.merchantId}`);

                if (!response.ok) {
                    throw new Error('Failed to fetch merchant profile');
                }

                const merchantData = await response.json();
                console.log('Merchant data:', merchantData);

                if (merchantData.wallets && merchantData.wallets.length > 0) {
                    // Only show chains the merchant has configured
                    merchantChains = merchantData.wallets
                        .filter(w => w.isActive && CHAIN_CONFIG[w.chain])
                        .map(w => ({
                            chain: w.chain,
                            address: w.address
                        }));

                    // Further filter by URL-specified chains if provided
                    if (currentProduct.enabledChains && currentProduct.enabledChains.length > 0) {
                        merchantChains = merchantChains.filter(mc =>
                            currentProduct.enabledChains.includes(mc.chain)
                        );
                        console.log('Filtered to specified chains:', currentProduct.enabledChains);
                    }

                    if (merchantChains.length === 0) {
                        chainOptionsContainer.innerHTML = `
                            <div class="text-center py-4 text-red-600 font-bold">
                                No payment chains available for this checkout.
                            </div>
                        `;
                        return;
                    }
                } else {
                    // No wallets configured - show message
                    chainOptionsContainer.innerHTML = `
                        <div class="text-center py-4 text-red-600 font-bold">
                            Merchant has not configured any payment wallets yet.
                        </div>
                    `;
                    return;
                }

                renderChainOptions();
            } catch (error) {
                console.error('Error loading merchant chains:', error);
                // Fallback to testnet chains
                merchantChains = Object.keys(CHAIN_CONFIG)
                    .filter(key => CHAIN_CONFIG[key].network === 'testnet')
                    .map(key => ({ chain: key, address: null }));
                renderChainOptions();
            }
        }

        // Render chain options based on merchant's configured wallets
        function renderChainOptions() {
            const container = document.getElementById('chainOptions');

            if (merchantChains.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-4 text-gray-500">
                        No payment chains available
                    </div>
                `;
                return;
            }

            container.innerHTML = merchantChains.map((mc, index) => {
                const config = CHAIN_CONFIG[mc.chain];
                if (!config) return '';

                const isFirst = index === 0;
                return `
                    <label class="flex items-center space-x-3 p-4 border-4 border-black cursor-pointer hover:bg-gray-100">
                        <input type="radio" name="chain" value="${mc.chain}" class="w-5 h-5" ${isFirst ? 'checked' : ''}>
                        <div class="flex-1">
                            <div class="font-bold text-black">${config.chainName.toUpperCase()}</div>
                            <div class="text-sm text-gray-700">${config.description || config.network}</div>
                        </div>
                        <div class="text-sm font-mono font-bold text-black" id="balance_${mc.chain}">-- USDC</div>
                    </label>
                `;
            }).join('');

            // Add event listeners to chain radios
            setupChainListeners();

            // If first chain is auto-selected, enable pay button
            const firstRadio = document.querySelector('input[name="chain"]:checked');
            if (firstRadio) {
                document.getElementById('payBtn').disabled = false;
            }
        }

        // Setup chain radio button listeners
        function setupChainListeners() {
            const chainRadios = document.querySelectorAll('input[name="chain"]');
            chainRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    document.getElementById('payBtn').disabled = false;
                });
            });
        }

        // Go back to store
        function goBack() {
            window.location.href = '/public/store.html';
        }

        // Connect Wallet - shows modal for wallet selection
        function connectWallet() {
            console.log('Opening wallet selection modal...');
            showWalletModal();
        }

        // Disconnect wallet
        async function disconnectWallet() {
            console.log('Disconnecting wallet...');

            // Clear any cached permissions
            if (selectedWalletProvider) {
                try {
                    await selectedWalletProvider.request({
                        method: "wallet_revokePermissions",
                        params: [{ eth_accounts: {} }]
                    });
                } catch (err) {
                    console.log('Error revoking permissions (may not be supported):', err);
                }
            }

            // Clear local state
            provider = null;
            signer = null;
            connectedAddress = null;
            selectedWalletProvider = null;

            // Update UI
            document.getElementById('connectWalletBtn').classList.remove('hidden');
            document.getElementById('walletInfo').classList.add('hidden');
            document.getElementById('customerSection').classList.add('hidden');
            document.getElementById('paymentSection').classList.add('hidden');

            showSuccess('Wallet disconnected. You can now connect a different wallet.');
        }

        // Update USDC balance on all merchant's enabled chains
        async function updateUSDCBalance() {
            if (!connectedAddress) return;

            console.log('Checking USDC balance on merchant chains for:', connectedAddress);

            // Check balance on each of the merchant's enabled chains
            for (const mc of merchantChains) {
                await checkBalanceOnChain(mc.chain);
            }
        }

        async function checkBalanceOnChain(chainKey) {
            try {
                const config = CHAIN_CONFIG[chainKey];
                if (!config) return;

                console.log(`Checking ${config.chainName} balance...`);

                // Create provider for this specific chain
                const chainProvider = new ethers.JsonRpcProvider(config.rpcUrls[0]);
                const usdcContract = new ethers.Contract(config.usdcAddress, USDC_ABI, chainProvider);

                const balance = await usdcContract.balanceOf(connectedAddress);
                const decimals = await usdcContract.decimals();
                const formattedBalance = ethers.formatUnits(balance, decimals);

                // Update the balance display for this chain
                const balanceElement = document.getElementById(`balance_${chainKey}`);
                if (balanceElement) {
                    balanceElement.textContent = `${parseFloat(formattedBalance).toFixed(2)} USDC`;

                    // Add color coding
                    if (parseFloat(formattedBalance) > 0) {
                        balanceElement.classList.add('text-green-600');
                        balanceElement.classList.remove('text-gray-400');
                    } else {
                        balanceElement.classList.add('text-gray-400');
                        balanceElement.classList.remove('text-green-600');
                    }
                }

                console.log(`${config.chainName}: ${formattedBalance} USDC`);
            } catch (error) {
                console.error(`Error checking ${chainKey} balance:`, error);

                // Show error state
                const balanceElement = document.getElementById(`balance_${chainKey}`);
                if (balanceElement) {
                    balanceElement.textContent = '-- USDC';
                    balanceElement.classList.add('text-gray-400');
                }

                const configObj = CHAIN_CONFIG[chainKey];
                if (configObj) {
                    console.log(`${configObj.chainName}: Unable to check balance`);
                }
            }
        }

        // Create order and initiate payment
        async function initiatePayment() {
            if (!signer || !currentProduct) {
                showError('Please connect wallet first');
                return;
            }

            // Validate customer email
            const customerEmail = document.getElementById('customerEmail').value.trim();
            const customerName = document.getElementById('customerName').value.trim();
            
            if (!customerEmail) {
                showError('Please enter your email address');
                document.getElementById('customerEmail').focus();
                return;
            }
            
            // Basic email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(customerEmail)) {
                showError('Please enter a valid email address');
                document.getElementById('customerEmail').focus();
                return;
            }

            const selectedChain = document.querySelector('input[name="chain"]:checked');
            if (!selectedChain) {
                showError('Please select a payment chain');
                return;
            }

            try {
                showTxStatus('Creating order...');

                let orderData;
                const chainConfig = CHAIN_CONFIG[selectedChain.value];
                
                // Try API first for database persistence
                console.log('Attempting to create order via API...');
                console.log('Product:', currentProduct);
                console.log('Chain:', selectedChain.value);
                
                try {
                    const apiUrl = '/api/v1/orders';
                    console.log('Calling API:', apiUrl);

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            amount: currentProduct.price,
                            chain: selectedChain.value,
                            productId: currentProduct.id,
                            productName: currentProduct.name,
                            customerEmail: customerEmail,
                            customerName: customerName || null,
                            merchantId: currentProduct.merchantId || 'DEMO',
                            paymentAddress: chainConfig.paymentAddress // Required for order creation
                        })
                    });
                    
                    console.log('API Response status:', response.status);
                    console.log('API Response headers:', response.headers);
                    
                    if (response.ok) {
                        const apiResponse = await response.json();
                        // Extract the order from the API response wrapper
                        orderData = apiResponse.order || apiResponse;
                        // Add chain config addresses
                        orderData.usdcAddress = chainConfig.usdcAddress;
                        orderData.paymentAddress = orderData.paymentAddress || chainConfig.paymentAddress;
                        console.log('[SUCCESS] Order created via API:', orderData);
                    } else {
                        const errorText = await response.text();
                        console.error('[ERROR] API Error Response:', errorText);
                        throw new Error('API returned error: ' + response.status);
                    }
                } catch (apiError) {
                    console.error('[ERROR] API Error details:', apiError);
                    console.log('[WARNING] Using localStorage fallback');
                    // Fallback to localStorage
                    const mockOrderId = 'order_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    orderData = {
                        id: mockOrderId,
                        orderId: mockOrderId,
                        amount: currentProduct.price,
                        chain: selectedChain.value,
                        paymentAddress: chainConfig.paymentAddress,
                        usdcAddress: chainConfig.usdcAddress,
                        productId: currentProduct.id,
                        productName: currentProduct.name,
                        createdAt: new Date().toISOString(),
                        expiresAt: new Date(Date.now() + 30 * 60 * 1000).toISOString(),
                        status: 'PENDING',
                        txHash: null,
                        fromAddress: null
                    };
                    
                    // Store in localStorage for demo
                    localStorage.setItem('currentOrder', JSON.stringify(orderData));
                    
                    // Add to demoOrders array
                    const demoOrders = JSON.parse(localStorage.getItem('demoOrders') || '[]');
                    demoOrders.push(orderData);
                    localStorage.setItem('demoOrders', JSON.stringify(demoOrders));
                }

                console.log('Order created:', orderData);

                // Now process payment
                await processPayment(orderData, selectedChain.value);

            } catch (error) {
                console.error('Payment error:', error);
                showError('Payment failed: ' + error.message);
                hideTxStatus();
            }
        }

        async function processPayment(order, chainKey) {
            const chainConfig = CHAIN_CONFIG[chainKey];
            const targetChainId = parseInt(chainConfig.chainId, 16);

            // ALWAYS switch to correct chain FIRST before any contract calls
            showTxStatus('Checking network...');

            try {
                const currentChainId = await provider.getNetwork().then(n => Number(n.chainId));
                console.log('Current chain:', currentChainId, 'Target chain:', targetChainId);

                const walletProvider = selectedWalletProvider || window.ethereum;

                if (currentChainId !== targetChainId) {
                    showTxStatus(`Switching to ${chainConfig.chainName}...`);

                    try {
                        await walletProvider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: chainConfig.chainId }],
                        });
                    } catch (switchError) {
                        // Chain not added, add it
                        if (switchError.code === 4902 || switchError.code === -32603) {
                            showTxStatus(`Adding ${chainConfig.chainName} to wallet...`);
                            await walletProvider.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: chainConfig.chainId,
                                    chainName: chainConfig.chainName,
                                    rpcUrls: chainConfig.rpcUrls,
                                    blockExplorerUrls: chainConfig.blockExplorerUrls,
                                    nativeCurrency: chainConfig.nativeCurrency
                                }],
                            });
                        } else if (switchError.code === 4001) {
                            throw new Error('You rejected the network switch. Please switch to ' + chainConfig.chainName + ' to continue.');
                        } else {
                            throw switchError;
                        }
                    }

                    // Wait a moment for the chain switch to complete
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            } catch (networkError) {
                console.error('Network switch error:', networkError);
                throw new Error('Failed to switch network: ' + networkError.message);
            }

            // Reinitialize provider and signer AFTER chain switch
            const activeProvider = selectedWalletProvider || window.ethereum;
            provider = new ethers.BrowserProvider(activeProvider);
            signer = await provider.getSigner();

            // Verify we're on the correct chain now
            const verifyChainId = await provider.getNetwork().then(n => Number(n.chainId));
            if (verifyChainId !== targetChainId) {
                throw new Error(`Please switch to ${chainConfig.chainName} in your wallet to complete this payment.`);
            }

            console.log('Successfully on chain:', verifyChainId);

            // Validate addresses
            if (!order.usdcAddress || !order.paymentAddress) {
                throw new Error('Missing contract or payment addresses');
            }

            console.log('USDC Address:', order.usdcAddress);
            console.log('Payment Address:', order.paymentAddress);

            // Create USDC contract (now on correct chain)
            const usdcContract = new ethers.Contract(
                order.usdcAddress,
                USDC_ABI,
                signer
            );

            // Get decimals - this should work now that we're on the right chain
            showTxStatus('Preparing USDC transfer...');
            const decimals = await usdcContract.decimals();
            const amount = ethers.parseUnits(order.amount.toString(), decimals);

            showTxStatus('Preparing transaction...');

            // Send USDC transfer
            showTxStatus('Please confirm transaction in your wallet...');
            const tx = await usdcContract.transfer(order.paymentAddress, amount);
            
            showTxStatus('Transaction sent! Waiting for confirmation...');
            console.log('Transaction hash:', tx.hash);

            // Show explorer link
            const explorerUrl = `${chainConfig.blockExplorerUrls[0]}/tx/${tx.hash}`;
            document.getElementById('txLink').href = explorerUrl;
            document.getElementById('txLink').classList.remove('hidden');

            // Update order with transaction hash (demo mode - localStorage)
            try {
                const storedOrder = JSON.parse(localStorage.getItem('currentOrder'));
                if (storedOrder) {
                    storedOrder.txHash = tx.hash;
                    storedOrder.fromAddress = connectedAddress;
                    storedOrder.status = 'PAID';
                    localStorage.setItem('currentOrder', JSON.stringify(storedOrder));
                    
                    // Update demo orders list (only if using localStorage fallback)
                    const demoOrders = JSON.parse(localStorage.getItem('demoOrders') || '[]');
                    const orderIndex = demoOrders.findIndex(o => o.id === order.id);
                    if (orderIndex >= 0) {
                        demoOrders[orderIndex].status = 'PAID';
                        demoOrders[orderIndex].txHash = tx.hash;
                        demoOrders[orderIndex].fromAddress = connectedAddress;
                        localStorage.setItem('demoOrders', JSON.stringify(demoOrders));
                        console.log('Updated localStorage order with tx hash:', tx.hash);
                    }
                    // No error if not found - it's probably in the database instead
                }
            } catch (err) {
                console.error('Failed to update order with tx hash:', err);
            }

            // Wait for confirmation
            const receipt = await tx.wait();
            console.log('Transaction confirmed:', receipt);

            // Update order status to confirmed in database
            console.log('Confirming order in database...');
            console.log('Order ID:', order.id);
            console.log('TX Hash:', tx.hash);

            try {
                const confirmUrl = `/api/v1/orders/${order.id}/confirm`;
                console.log('Calling confirm API:', confirmUrl);

                const confirmResponse = await fetch(confirmUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        orderId: order.id,
                        txHash: tx.hash,
                        fromAddress: connectedAddress,
                        blockNumber: receipt.blockNumber.toString(),
                        confirmations: receipt.confirmations
                    })
                });

                console.log('Confirm API Response status:', confirmResponse.status);

                if (confirmResponse.ok) {
                    const confirmData = await confirmResponse.json();
                    console.log('[SUCCESS] Order confirmed in database:', confirmData);
                } else {
                    const errorText = await confirmResponse.text();
                    console.error('[ERROR] Confirm API Error:', errorText);
                }
            } catch (err) {
                console.error('[ERROR] Failed to confirm order in database:', err);
            }

            // Show the success screen
            showPaymentSuccess(currentProduct, chainKey, explorerUrl);
        }

        // Show full-page payment success screen
        function showPaymentSuccess(product, chainKey, explorerUrl) {
            // Hide all other sections
            document.getElementById('productSummary').classList.add('hidden');
            document.getElementById('walletSection').classList.add('hidden');
            document.getElementById('customerSection').classList.add('hidden');
            document.getElementById('paymentSection').classList.add('hidden');
            document.getElementById('errorMessage').classList.add('hidden');
            document.getElementById('successMessage').classList.add('hidden');

            // Populate success screen details
            document.getElementById('successProductName').textContent = product.name;
            document.getElementById('successAmount').textContent = `$${product.price} USDC`;
            document.getElementById('successChain').textContent = CHAIN_CONFIG[chainKey]?.chainName || chainKey;
            document.getElementById('successTxLink').href = explorerUrl;

            // Show success screen
            document.getElementById('paymentSuccessScreen').classList.remove('hidden');

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Buy again - reload the same product
        function buyAgain() {
            // Reset UI
            document.getElementById('paymentSuccessScreen').classList.add('hidden');
            document.getElementById('productSummary').classList.remove('hidden');
            document.getElementById('walletSection').classList.remove('hidden');

            // Reset wallet connection UI
            document.getElementById('connectWalletBtn').classList.remove('hidden');
            document.getElementById('walletInfo').classList.add('hidden');
            document.getElementById('customerSection').classList.add('hidden');
            document.getElementById('paymentSection').classList.add('hidden');

            // Clear form
            document.getElementById('customerEmail').value = '';
            document.getElementById('customerName').value = '';

            // Uncheck chain selection
            document.querySelectorAll('input[name="chain"]').forEach(r => r.checked = false);
            document.getElementById('payBtn').disabled = true;
            document.getElementById('payBtn').textContent = 'PAY WITH USDC';

            // Hide tx status
            hideTxStatus();
            document.getElementById('txLink').classList.add('hidden');

            // Disconnect wallet so user can reconnect
            provider = null;
            signer = null;
            connectedAddress = null;
            selectedWalletProvider = null;

            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // UI Helper functions
        function showError(message) {
            hideMessages();
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.querySelector('p').textContent = message;
            errorDiv.classList.remove('hidden');
        }

        function showSuccess(message) {
            hideMessages();
            const successDiv = document.getElementById('successMessage');
            successDiv.querySelector('p').textContent = message;
            successDiv.classList.remove('hidden');
        }

        function hideMessages() {
            document.getElementById('errorMessage').classList.add('hidden');
            document.getElementById('successMessage').classList.add('hidden');
        }

        function showTxStatus(message) {
            document.getElementById('txStatus').classList.remove('hidden');
            document.getElementById('txMessage').textContent = message;
        }

        function hideTxStatus() {
            document.getElementById('txStatus').classList.add('hidden');
        }

        // Listen for account changes
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', async (accounts) => {
                if (accounts.length === 0) {
                    disconnectWallet();
                } else if (connectedAddress) {
                    // Only update if already connected - don't re-open modal
                    connectedAddress = accounts[0];
                    document.getElementById('walletAddress').textContent =
                        connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
                    await updateUSDCBalance();
                    console.log('Account changed to:', connectedAddress);
                }
            });

            window.ethereum.on('chainChanged', () => {
                updateUSDCBalance();
            });
        }

        // Add event listeners when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Crypto payment page loaded');
            
            // Load product info first
            loadProductInfo();
            
            // Connect wallet button
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                connectBtn.addEventListener('click', connectWallet);
            }
            
            // Disconnect wallet button
            const disconnectBtn = document.getElementById('disconnectBtn');
            if (disconnectBtn) {
                disconnectBtn.addEventListener('click', disconnectWallet);
            }
            
            // Back button
            const backBtn = document.getElementById('backBtn');
            if (backBtn) {
                backBtn.addEventListener('click', goBack);
            }
            
            // Pay button
            const payBtn = document.getElementById('payBtn');
            if (payBtn) {
                payBtn.addEventListener('click', initiatePayment);
            }

            // Chain selection
            const chainRadios = document.querySelectorAll('input[name="chain"]');
            chainRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    document.getElementById('payBtn').disabled = false;
                });
            });
        });

        // i18n functionality
        let currentLang = localStorage.getItem('preferredLanguage') || 'en';
        let translations = {};

        async function loadTranslations(lang) {
            try {
                const response = await fetch(`./locales/crypto-pay-${lang}.json`);
                translations = await response.json();
                applyTranslations();
            } catch (error) {
                console.error('Failed to load translations:', error);
            }
        }

        function applyTranslations() {
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                const keys = key.split('.');
                let value = translations;

                for (const k of keys) {
                    value = value[k];
                    if (!value) break;
                }

                if (value) {
                    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                        element.placeholder = value;
                    } else {
                        element.textContent = value;
                    }
                }
            });
        }

        // Language selector
        document.getElementById('languageSelector').addEventListener('change', (e) => {
            currentLang = e.target.value;
            localStorage.setItem('preferredLanguage', currentLang);
            loadTranslations(currentLang);
        });

        // Set initial language
        document.getElementById('languageSelector').value = currentLang;
        loadTranslations(currentLang);

        // Night mode toggle
        const nightModeToggle = document.getElementById('nightModeToggle');
        const nightIcon = document.querySelector('.night-icon');

        // Check for saved night mode preference
        if (localStorage.getItem('nightMode') === 'true') {
            document.body.classList.add('night-mode');
            const currentLang = localStorage.getItem('language') || 'en';
            fetch(`/locales/${currentLang}.json`)
                .then(res => res.json())
                .then(translations => {
                    nightIcon.textContent = translations.nav.day;
                    nightIcon.setAttribute('data-i18n', 'nav.day');
                });
        }

        nightModeToggle.addEventListener('click', () => {
            document.body.classList.toggle('night-mode');
            const isNightMode = document.body.classList.contains('night-mode');
            localStorage.setItem('nightMode', isNightMode);

            // Update translation
            const currentLang = localStorage.getItem('language') || 'en';
            fetch(`/locales/${currentLang}.json`)
                .then(res => res.json())
                .then(translations => {
                    nightIcon.textContent = isNightMode ? translations.nav.day : translations.nav.night;
                    nightIcon.setAttribute('data-i18n', isNightMode ? 'nav.day' : 'nav.night');
                });
        });
    </script>
</body>
</html>