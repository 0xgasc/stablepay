<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#FFFFFF">
    <title data-i18n="title">Crypto Payment - StablePay</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
    <!-- Solana Web3.js for Solana chain support -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Space Grotesk', sans-serif;
        }
        body {
            background: #FFFFFF;
            font-family: 'Space Grotesk', sans-serif;
        }
        body.night-mode {
            background: #1a1a1a;
            color: #fff;
        }
        body.night-mode .bg-white {
            background: #000 !important;
        }
        body.night-mode .text-black {
            color: #fff !important;
        }

        body.night-mode header .text-black,
        body.night-mode nav .text-black,
        body.night-mode header a,
        body.night-mode nav a,
        body.night-mode header span,
        body.night-mode nav span {
            color: #fff !important;
        }
        body.night-mode select,
        body.night-mode option {
            background: #000 !important;
            color: #fff !important;
            border-color: #fff !important;
        }
        body.night-mode .text-gray-700 {
            color: #ccc !important;
        }
        body.night-mode .text-gray-400 {
            color: #999 !important;
        }
        body.night-mode .text-gray-500 {
            color: #888 !important;
        }
        body.night-mode .brutal-border,
        body.night-mode .border-black {
            border-color: #fff !important;
        }
        body.night-mode .border-gray-300 {
            border-color: #666 !important;
        }
        body.night-mode [style*="box-shadow"][style*="#000"] {
            box-shadow: 8px 8px 0px #fff !important;
        }
        body.night-mode .shadow-brutal {
            box-shadow: 8px 8px 0px #fff !important;
        }
        .brutal-border {
            border: 4px solid #000;
        }
        .shadow-brutal {
            box-shadow: 8px 8px 0px #000;
        }
        .btn-brutal {
            border: 4px solid #000;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.05em;
            transition: all 0.2s;
        }
        .btn-brutal:hover {
            transform: translate(4px, 4px);
            box-shadow: 4px 4px 0px #000;
        }
        body.night-mode .btn-brutal {
            border-color: #fff;
        }
        body.night-mode .btn-brutal:hover {
            box-shadow: 4px 4px 0px #fff;
        }
        /* Wallet modal night mode */
        body.night-mode #walletModal > div:nth-child(2) {
            background: #1a1a1a !important;
            border-color: #fff !important;
        }
        body.night-mode #walletModal h3,
        body.night-mode #walletModal button span {
            color: #fff !important;
        }
        body.night-mode #walletModal button {
            border-color: #fff !important;
        }
        body.night-mode #walletModal button:hover {
            background: #333 !important;
        }
        /* Success screen night mode */
        body.night-mode #paymentSuccessScreen {
            background: #1a1a1a !important;
            border-color: #fff !important;
        }
        body.night-mode #paymentSuccessScreen h2,
        body.night-mode #paymentSuccessScreen span {
            color: #fff !important;
        }
        body.night-mode #paymentSuccessScreen .border-4 {
            border-color: #fff !important;
        }
        input, select {
            border: 4px solid #000;
            border-radius: 0;
        }
        body.night-mode input,
        body.night-mode select {
            border-color: #fff;
            background: #000;
            color: #fff;
        }
        .testnet-badge {
            background: #FFA500;
            color: #000;
            border-bottom: 4px solid #000;
        }
        body.night-mode .testnet-badge {
            background: #FF8C00;
            color: #fff;
            border-color: #fff;
        }

        /* ===== MOBILE OPTIMIZATIONS ===== */

        /* Safe area padding for notched devices (iPhone X+) */
        body {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* Prevent iOS zoom on input focus - minimum 16px */
        input, select, textarea {
            font-size: 16px !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Touch-friendly button sizes (minimum 44px) */
        .btn-brutal, button, .touch-target {
            min-height: 48px;
            min-width: 48px;
        }

        /* Better touch feedback */
        .btn-brutal:active, button:active {
            transform: translate(2px, 2px);
            opacity: 0.9;
        }

        /* Remove tap highlight on mobile */
        * {
            -webkit-tap-highlight-color: transparent;
        }

        /* Smooth scrolling for iOS */
        html {
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }

        /* Fix for iOS input shadows */
        input, textarea {
            -webkit-appearance: none;
            box-shadow: none;
        }

        /* Mobile modal improvements */
        @media (max-width: 640px) {
            /* Adjust shadow for smaller screens */
            .shadow-brutal {
                box-shadow: 4px 4px 0px #000;
            }
            body.night-mode .shadow-brutal {
                box-shadow: 4px 4px 0px #fff !important;
            }

            /* Larger touch targets on mobile */
            .btn-brutal {
                padding: 16px 20px;
                font-size: 14px;
            }

            /* Better header sizing */
            nav .text-3xl {
                font-size: 1.25rem;
            }

            /* Full-width modal on mobile */
            #walletModal > div:nth-child(2) {
                margin: 16px;
                max-height: calc(100vh - 32px);
                overflow-y: auto;
            }

            /* Larger wallet options for touch */
            #walletOptions button {
                padding: 16px;
                min-height: 64px;
            }

            /* Stack success buttons on mobile */
            #paymentSuccessScreen .flex.gap-4 {
                flex-direction: column;
            }

            /* Adjust heading sizes */
            h1.text-4xl {
                font-size: 1.75rem;
            }
            h2.text-3xl {
                font-size: 1.5rem;
            }
            h2.text-2xl {
                font-size: 1.25rem;
            }

            /* Better spacing for cards */
            .border-4 {
                border-width: 3px;
            }

            /* Adjust container padding */
            .container {
                padding-left: 12px;
                padding-right: 12px;
            }
        }

        /* Extra small devices (iPhone SE, etc.) */
        @media (max-width: 375px) {
            nav .text-3xl {
                font-size: 1.1rem;
            }

            h1.text-4xl {
                font-size: 1.5rem;
            }

            .btn-brutal {
                padding: 12px 16px;
                font-size: 13px;
            }

            #languageSelector, #nightModeToggle {
                padding: 8px 12px;
                font-size: 12px;
            }
        }

        /* Tablet (iPad) optimizations */
        @media (min-width: 768px) and (max-width: 1024px) {
            .container {
                max-width: 600px;
            }
        }

        /* Landscape mode on phones */
        @media (max-height: 500px) and (orientation: landscape) {
            .container {
                padding-top: 8px;
                padding-bottom: 8px;
            }

            #walletModal > div:nth-child(2) {
                max-height: 90vh;
                margin: 8px;
            }
        }

        /* Loading state animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Mobile wallet deep link button */
        .mobile-wallet-link {
            display: none;
        }
        @media (max-width: 768px) {
            .mobile-wallet-link {
                display: block;
            }
        }
    </style>
</head>
<body class="min-h-screen">
    <!-- Testnet Banner -->
    <div class="testnet-badge text-center py-3 text-sm font-bold tracking-wide" style="text-transform: uppercase;">
        <span data-i18n="banner">TESTNET MODE - USING BASE SEPOLIA & ETHEREUM SEPOLIA</span>
    </div>

    <!-- Navigation -->
    <nav class="bg-white border-b-4 border-black">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-20">
                <a href="/" class="text-3xl font-bold tracking-tight text-black" style="text-transform: uppercase;">
                    STABLEPAY
                </a>
                <div class="flex items-center gap-4">
                    <!-- Language Selector -->
                    <select id="languageSelector" class="px-3 py-2 bg-white text-black font-bold text-sm">
                        <option value="en">EN</option>
                        <option value="es">ES</option>
                        <option value="fr">FR</option>
                        <option value="pt">PT</option>
                    </select>
                    <!-- Night Mode Toggle -->
                    <button id="nightModeToggle" class="px-4 py-2 bg-white text-black font-bold text-sm btn-brutal">
                        <span class="night-icon" data-i18n="nav.night">NIGHT</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 py-8 max-w-2xl">
        <!-- Back Button -->
        <div class="mb-6">
            <button id="backBtn" class="text-black font-bold flex items-center tracking-wide btn-brutal px-4 py-2" style="text-transform: uppercase; background: #00E5FF;" data-i18n="backBtn">
                BACK TO STORE
            </button>
        </div>

        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-3 text-black tracking-tight" style="text-transform: uppercase;" data-i18n="heading">COMPLETE YOUR PURCHASE</h1>
            <p class="text-gray-700" data-i18n="subheading">Pay with USDC on testnet</p>
        </div>

        <!-- Product Summary -->
        <div id="productSummary" class="bg-white border-4 border-black p-6 shadow-brutal mb-6">
            <h2 class="text-2xl font-bold mb-4 text-black tracking-wide" style="text-transform: uppercase;" data-i18n="summary.heading">ORDER SUMMARY</h2>
            <div class="space-y-4">
                <div class="flex justify-between pb-3 border-b-4 border-black">
                    <span class="text-gray-700 font-bold tracking-wide" style="text-transform: uppercase;" data-i18n="summary.product">PRODUCT</span>
                    <span id="productName" class="text-black font-bold">Loading...</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-700 font-bold tracking-wide" style="text-transform: uppercase;" data-i18n="summary.amount">AMOUNT</span>
                    <span id="productPrice" class="text-black font-bold" style="color: #00E5FF;">Loading...</span>
                </div>
            </div>
        </div>

        <!-- Wallet Connection -->
        <div id="walletSection" class="bg-white border-4 border-black p-6 shadow-brutal mb-6">
            <div id="connectWalletBtn" class="text-center">
                <button id="connectBtn" class="w-full px-6 py-4 font-bold tracking-wide btn-brutal text-black" style="text-transform: uppercase; background: #4FC3F7;" data-i18n="wallet.connect">
                    CONNECT WALLET
                </button>
            </div>
            <div id="walletInfo" class="hidden">
                <div class="flex justify-between items-center pb-4 border-b-4 border-black">
                    <div>
                        <p class="text-sm text-gray-700 font-bold tracking-wide" style="text-transform: uppercase;" data-i18n="wallet.connected">CONNECTED WALLET</p>
                        <p class="font-mono text-sm text-black font-bold" id="walletAddress"></p>
                    </div>
                    <button id="disconnectBtn" class="px-3 py-2 font-bold text-sm btn-brutal text-black" style="background: #FF6B6B; text-transform: uppercase;" data-i18n="wallet.disconnect">
                        DISCONNECT
                    </button>
                </div>
                <div class="mt-4 pt-4">
                    <p class="text-sm text-gray-700 font-bold tracking-wide mb-3" style="text-transform: uppercase;">STABLECOIN BALANCES</p>
                    <p class="text-xs text-gray-500 mb-2">Balances shown next to each chain below</p>
                </div>
            </div>
        </div>

        <!-- Customer Information -->
        <div id="customerSection" class="hidden bg-white border-4 border-black p-6 shadow-brutal mb-6">
            <h2 class="text-2xl font-bold mb-4 text-black tracking-wide" style="text-transform: uppercase;" data-i18n="customer.heading">CUSTOMER INFORMATION</h2>
            <div class="space-y-4">
                <div>
                    <label for="customerEmail" class="block text-sm font-bold text-black mb-2 tracking-wide" style="text-transform: uppercase;" data-i18n="customer.email">
                        EMAIL ADDRESS *
                    </label>
                    <input
                        type="email"
                        id="customerEmail"
                        placeholder="your@email.com"
                        class="w-full px-4 py-3 bg-white text-black focus:outline-none"
                        required
                    />
                    <p class="text-xs text-gray-500 mt-2" data-i18n="customer.emailHint">We'll send your receipt to this address</p>
                </div>
                <div>
                    <label for="customerName" class="block text-sm font-bold text-black mb-2 tracking-wide" style="text-transform: uppercase;" data-i18n="customer.name">
                        FULL NAME (OPTIONAL)
                    </label>
                    <input
                        type="text"
                        id="customerName"
                        placeholder="John Doe"
                        class="w-full px-4 py-3 bg-white text-black focus:outline-none"
                    />
                </div>
            </div>
        </div>

        <!-- Chain Selection & Payment - Shown before wallet connection -->
        <div id="paymentSection" class="bg-white border-4 border-black p-6 shadow-brutal mb-6">
            <h2 class="text-2xl font-bold mb-4 text-black tracking-wide" style="text-transform: uppercase;" data-i18n="payment.heading">SELECT PAYMENT CHAIN</h2>

            <!-- Dynamic chain options - populated based on merchant's configured wallets -->
            <div id="chainOptions" class="space-y-4 mb-6">
                <div class="text-center py-4 text-gray-500">
                    <span class="animate-pulse">Loading available chains...</span>
                </div>
            </div>

            <button
                id="payBtn"
                class="w-full px-6 py-4 font-bold tracking-wide btn-brutal text-black disabled:opacity-50 disabled:cursor-not-allowed"
                style="text-transform: uppercase; background: #00E5FF;"
                disabled
                data-i18n="payment.payBtn"
            >
                PAY WITH USDC
            </button>

            <div id="txStatus" class="hidden mt-4 p-4 border-4 border-black" style="background: #E3F2FD;">
                <p class="text-sm font-bold mb-2 text-black tracking-wide" style="text-transform: uppercase;" data-i18n="payment.txStatus">TRANSACTION STATUS</p>
                <p id="txMessage" class="text-sm text-black font-bold"></p>
                <a id="txLink" href="#" target="_blank" class="text-black font-bold text-sm mt-2 inline-block hidden underline" data-i18n="payment.viewExplorer">
                    VIEW ON EXPLORER
                </a>
            </div>
        </div>

        <!-- Error/Success Messages -->
        <div id="errorMessage" class="hidden border-4 border-black p-4 mb-6" style="background: #FFE5E5;">
            <p class="text-black font-bold"></p>
        </div>

        <div id="successMessage" class="hidden border-4 border-black p-4 mb-6" style="background: #E5FFE5;">
            <p class="text-black font-bold"></p>
        </div>

        <!-- Payment Success Screen (shown after successful payment) -->
        <div id="paymentSuccessScreen" class="hidden bg-white border-4 border-black p-8 shadow-brutal text-center">
            <div class="text-6xl mb-4">âœ…</div>
            <h2 class="text-3xl font-bold text-black mb-2" style="text-transform: uppercase;">PAYMENT SUCCESSFUL!</h2>
            <p class="text-gray-700 mb-6">Your transaction has been confirmed on the blockchain.</p>

            <div class="border-4 border-black p-4 mb-6 text-left" style="background: #F0FFF0;">
                <div class="flex justify-between mb-2">
                    <span class="text-gray-700 font-bold">Product:</span>
                    <span id="successProductName" class="text-black font-bold">-</span>
                </div>
                <div class="flex justify-between mb-2">
                    <span class="text-gray-700 font-bold">Amount:</span>
                    <span id="successAmount" class="text-black font-bold">-</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-700 font-bold">Network:</span>
                    <span id="successChain" class="text-black font-bold">-</span>
                </div>
            </div>

            <a id="successTxLink" href="#" target="_blank"
               class="block w-full px-6 py-4 font-bold tracking-wide btn-brutal text-black mb-4"
               style="text-transform: uppercase; background: #E3F2FD; text-decoration: none;">
                VIEW TRANSACTION ON EXPLORER â†’
            </a>

            <div class="flex gap-4">
                <button onclick="buyAgain()"
                        class="flex-1 px-6 py-4 font-bold tracking-wide btn-brutal text-black"
                        style="text-transform: uppercase; background: #00E5FF;">
                    BUY AGAIN
                </button>
                <button onclick="goBack()"
                        class="flex-1 px-6 py-4 font-bold tracking-wide btn-brutal text-black"
                        style="text-transform: uppercase; background: #FFF;">
                    BACK TO STORE
                </button>
            </div>
        </div>
    </div>

    <!-- Wallet Selection Modal -->
    <div id="walletModal" class="hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black bg-opacity-50" onclick="closeWalletModal()"></div>
        <div class="relative bg-white border-4 border-black shadow-brutal p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-bold text-black tracking-wide" style="text-transform: uppercase;">SELECT WALLET</h3>
                <button onclick="closeWalletModal()" class="text-black font-bold text-2xl hover:text-gray-600">&times;</button>
            </div>
            <div id="walletOptions" class="space-y-3">
                <!-- Wallet options will be populated by JS -->
            </div>
            <p class="text-xs text-gray-500 mt-4 text-center">Don't have a wallet? <a href="https://metamask.io/download/" target="_blank" class="underline font-bold">Get MetaMask</a></p>
        </div>
    </div>

    <script>
        // All supported chain configurations with multi-token support
        const CHAIN_CONFIG = {
            // ========== EVM TESTNETS ==========
            BASE_SEPOLIA: {
                type: 'evm',
                chainId: '0x14a34', // 84532
                chainName: 'Base Sepolia',
                rpcUrls: ['https://sepolia.base.org'],
                blockExplorerUrls: ['https://sepolia.basescan.org'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                network: 'testnet',
                description: 'Base testnet - Lower fees',
                tokens: {
                    USDC: { address: '0x036CbD53842c5426634e7929541eC2318f3dCF7e', decimals: 6, name: 'USD Coin' }
                }
            },
            ETHEREUM_SEPOLIA: {
                type: 'evm',
                chainId: '0xaa36a7', // 11155111
                chainName: 'Ethereum Sepolia',
                rpcUrls: ['https://eth-sepolia.g.alchemy.com/v2/demo'],
                blockExplorerUrls: ['https://sepolia.etherscan.io'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                network: 'testnet',
                description: 'Ethereum testnet',
                tokens: {
                    USDC: { address: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238', decimals: 6, name: 'USD Coin' }
                }
            },
            POLYGON_MUMBAI: {
                type: 'evm',
                chainId: '0x13882', // 80002
                chainName: 'Polygon Amoy',
                rpcUrls: ['https://rpc-amoy.polygon.technology'],
                blockExplorerUrls: ['https://amoy.polygonscan.com'],
                nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
                network: 'testnet',
                description: 'Polygon testnet',
                tokens: {
                    USDC: { address: '0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582', decimals: 6, name: 'USD Coin' }
                }
            },
            ARBITRUM_SEPOLIA: {
                type: 'evm',
                chainId: '0x66eee', // 421614
                chainName: 'Arbitrum Sepolia',
                rpcUrls: ['https://sepolia-rollup.arbitrum.io/rpc'],
                blockExplorerUrls: ['https://sepolia.arbiscan.io'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                network: 'testnet',
                description: 'Arbitrum testnet',
                tokens: {
                    USDC: { address: '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d', decimals: 6, name: 'USD Coin' }
                }
            },

            // ========== SOLANA TESTNETS ==========
            SOLANA_DEVNET: {
                type: 'solana',
                chainName: 'Solana Devnet',
                rpcUrls: ['https://api.devnet.solana.com'],
                blockExplorerUrls: ['https://explorer.solana.com/?cluster=devnet'],
                network: 'testnet',
                description: 'Solana testnet',
                tokens: {
                    USDC: { address: '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU', decimals: 6, name: 'USD Coin' }
                }
            },

            // ========== EVM MAINNETS ==========
            BASE_MAINNET: {
                type: 'evm',
                chainId: '0x2105', // 8453
                chainName: 'Base',
                rpcUrls: ['https://mainnet.base.org'],
                blockExplorerUrls: ['https://basescan.org'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                network: 'mainnet',
                description: 'Base - Recommended, low fees',
                tokens: {
                    USDC: { address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', decimals: 6, name: 'USD Coin' },
                    EURC: { address: '0x60a3E35Cc302bFA44Cb288Bc5a4F316Fdb1adb42', decimals: 6, name: 'Euro Coin' }
                }
            },
            ETHEREUM_MAINNET: {
                type: 'evm',
                chainId: '0x1', // 1
                chainName: 'Ethereum',
                rpcUrls: ['https://eth.llamarpc.com'],
                blockExplorerUrls: ['https://etherscan.io'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                network: 'mainnet',
                description: 'Ethereum mainnet',
                tokens: {
                    USDC: { address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', decimals: 6, name: 'USD Coin' },
                    EURC: { address: '0x1aBaEA1f7C830bD89Acc67eC4af516284b1bC33c', decimals: 6, name: 'Euro Coin' },
                    USDT: { address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', decimals: 6, name: 'Tether USD' }
                }
            },
            POLYGON_MAINNET: {
                type: 'evm',
                chainId: '0x89', // 137
                chainName: 'Polygon',
                rpcUrls: ['https://polygon-rpc.com'],
                blockExplorerUrls: ['https://polygonscan.com'],
                nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
                network: 'mainnet',
                description: 'Polygon - Fast & cheap',
                tokens: {
                    USDC: { address: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359', decimals: 6, name: 'USD Coin' },
                    USDT: { address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', decimals: 6, name: 'Tether USD' }
                }
            },
            ARBITRUM_MAINNET: {
                type: 'evm',
                chainId: '0xa4b1', // 42161
                chainName: 'Arbitrum One',
                rpcUrls: ['https://arb1.arbitrum.io/rpc'],
                blockExplorerUrls: ['https://arbiscan.io'],
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                network: 'mainnet',
                description: 'Arbitrum L2',
                tokens: {
                    USDC: { address: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831', decimals: 6, name: 'USD Coin' },
                    USDT: { address: '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9', decimals: 6, name: 'Tether USD' }
                }
            },

            // ========== SOLANA MAINNET ==========
            SOLANA_MAINNET: {
                type: 'solana',
                chainName: 'Solana',
                rpcUrls: ['https://api.mainnet-beta.solana.com'],
                blockExplorerUrls: ['https://explorer.solana.com'],
                network: 'mainnet',
                description: 'Solana - Fast & cheap',
                tokens: {
                    USDC: { address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', decimals: 6, name: 'USD Coin' },
                    USDT: { address: 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', decimals: 6, name: 'Tether USD' }
                }
            }
        };

        // Merchant's enabled chains (populated on load)
        let merchantChains = [];
        let selectedChainKey = null;
        let selectedToken = 'USDC'; // Default token

        // ERC20 ABI (for EVM tokens)
        const ERC20_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function transfer(address to, uint256 amount) returns (bool)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function symbol() view returns (string)"
        ];

        // State variables
        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let connectedWalletType = null; // 'evm' or 'solana'
        let currentProduct = null;
        let selectedWalletProvider = null;
        let solanaConnection = null;
        let solanaWallet = null;

        // Detect available wallets - returns both EVM and Solana wallets
        function detectWallets() {
            const wallets = [];

            // ========== EVM WALLETS ==========
            // Check for MetaMask (has isMetaMask flag)
            if (window.ethereum?.isMetaMask && !window.ethereum?.isPhantom) {
                wallets.push({
                    name: 'MetaMask',
                    icon: 'ðŸ¦Š',
                    provider: window.ethereum,
                    type: 'evm',
                    rdns: 'io.metamask'
                });
            }

            // Check for Phantom EVM
            if (window.phantom?.ethereum || window.ethereum?.isPhantom) {
                wallets.push({
                    name: 'Phantom (EVM)',
                    icon: 'ðŸ‘»',
                    provider: window.phantom?.ethereum || window.ethereum,
                    type: 'evm',
                    rdns: 'app.phantom.evm'
                });
            }

            // Check for Coinbase Wallet
            if (window.ethereum?.isCoinbaseWallet || window.coinbaseWalletExtension) {
                wallets.push({
                    name: 'Coinbase Wallet',
                    icon: 'ðŸ”µ',
                    provider: window.coinbaseWalletExtension || window.ethereum,
                    type: 'evm',
                    rdns: 'com.coinbase.wallet'
                });
            }

            // Check for Trust Wallet
            if (window.ethereum?.isTrust || window.trustwallet) {
                wallets.push({
                    name: 'Trust Wallet',
                    icon: 'ðŸ›¡ï¸',
                    provider: window.trustwallet?.ethereum || window.ethereum,
                    type: 'evm',
                    rdns: 'com.trustwallet.app'
                });
            }

            // Check for Rabby
            if (window.ethereum?.isRabby) {
                wallets.push({
                    name: 'Rabby',
                    icon: 'ðŸ°',
                    provider: window.ethereum,
                    type: 'evm',
                    rdns: 'io.rabby'
                });
            }

            // ========== SOLANA WALLETS ==========
            // Check for Phantom Solana
            if (window.phantom?.solana || window.solana?.isPhantom) {
                wallets.push({
                    name: 'Phantom (Solana)',
                    icon: 'ðŸ‘»',
                    provider: window.phantom?.solana || window.solana,
                    type: 'solana',
                    rdns: 'app.phantom.solana'
                });
            }

            // Check for Solflare
            if (window.solflare?.isSolflare) {
                wallets.push({
                    name: 'Solflare',
                    icon: 'â˜€ï¸',
                    provider: window.solflare,
                    type: 'solana',
                    rdns: 'com.solflare'
                });
            }

            // Use EIP-6963 if available (modern wallet detection)
            if (window.ethereum?.providers?.length > 0) {
                window.ethereum.providers.forEach(p => {
                    if (p.isMetaMask && !wallets.find(w => w.rdns === 'io.metamask')) {
                        wallets.push({ name: 'MetaMask', icon: 'ðŸ¦Š', provider: p, type: 'evm', rdns: 'io.metamask' });
                    }
                    if (p.isPhantom && !wallets.find(w => w.rdns === 'app.phantom.evm')) {
                        wallets.push({ name: 'Phantom (EVM)', icon: 'ðŸ‘»', provider: p, type: 'evm', rdns: 'app.phantom.evm' });
                    }
                    if (p.isCoinbaseWallet && !wallets.find(w => w.rdns === 'com.coinbase.wallet')) {
                        wallets.push({ name: 'Coinbase Wallet', icon: 'ðŸ”µ', provider: p, type: 'evm', rdns: 'com.coinbase.wallet' });
                    }
                });
            }

            // Fallback: if no specific wallet detected but ethereum exists
            if (wallets.length === 0 && window.ethereum) {
                wallets.push({
                    name: 'Browser Wallet',
                    icon: 'ðŸ”—',
                    provider: window.ethereum,
                    rdns: 'unknown'
                });
            }

            return wallets;
        }

        // Show wallet selection modal - filters by chain type if a chain is selected
        function showWalletModal() {
            let wallets = detectWallets();
            const walletOptionsDiv = document.getElementById('walletOptions');

            // Filter wallets based on selected chain type
            if (selectedChainKey) {
                const chainConfig = CHAIN_CONFIG[selectedChainKey];
                const chainType = chainConfig?.type || 'evm';
                wallets = wallets.filter(w => w.type === chainType);
            }

            if (wallets.length === 0) {
                const chainType = selectedChainKey ? (CHAIN_CONFIG[selectedChainKey]?.type || 'evm') : 'any';
                const walletSuggestion = chainType === 'solana'
                    ? '<a href="https://phantom.app/download" target="_blank" class="underline font-bold">Get Phantom</a>'
                    : '<a href="https://metamask.io/download/" target="_blank" class="underline font-bold">Get MetaMask</a>';

                walletOptionsDiv.innerHTML = `
                    <div class="text-center p-4">
                        <p class="text-black font-bold mb-4">No ${chainType === 'solana' ? 'Solana' : chainType === 'evm' ? 'EVM' : ''} wallets detected</p>
                        <p class="text-sm text-gray-600 mb-4">${walletSuggestion}</p>
                    </div>
                `;
            } else {
                walletOptionsDiv.innerHTML = wallets.map(wallet => `
                    <button onclick="connectWithWallet('${wallet.rdns}')"
                            class="w-full flex items-center gap-4 p-4 border-4 border-black hover:bg-gray-100 transition">
                        <span class="text-3xl">${wallet.icon}</span>
                        <span class="font-bold text-black text-lg">${wallet.name}</span>
                        <span class="text-xs text-gray-500 ml-auto">${wallet.type.toUpperCase()}</span>
                    </button>
                `).join('');
            }

            document.getElementById('walletModal').classList.remove('hidden');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.add('hidden');
        }

        // Connect with specific wallet - handles both EVM and Solana
        async function connectWithWallet(rdns) {
            const wallets = detectWallets();
            const wallet = wallets.find(w => w.rdns === rdns);

            if (!wallet) {
                showError('Wallet not found');
                return;
            }

            closeWalletModal();

            try {
                console.log(`Connecting with ${wallet.name} (${wallet.type})...`);

                if (wallet.type === 'solana') {
                    // Solana wallet connection
                    await connectSolanaWallet(wallet);
                } else {
                    // EVM wallet connection
                    await connectEVMWallet(wallet);
                }

                showSuccess(`Connected with ${wallet.name}!`);
            } catch (error) {
                console.error('Connection error:', error);
                if (error.code === 4001) {
                    showError('Connection rejected. Please try again.');
                } else {
                    showError('Failed to connect: ' + error.message);
                }
            }
        }

        // Connect EVM wallet (MetaMask, etc.)
        async function connectEVMWallet(wallet) {
            selectedWalletProvider = wallet.provider;

            const accounts = await wallet.provider.request({
                method: 'eth_requestAccounts'
            });

            if (!accounts || accounts.length === 0) {
                throw new Error('No accounts found. Please unlock your wallet.');
            }

            provider = new ethers.BrowserProvider(wallet.provider);
            signer = await provider.getSigner();
            connectedAddress = await signer.getAddress();
            connectedWalletType = 'evm';
            console.log('Connected EVM address:', connectedAddress);

            updateWalletUI(connectedAddress, 'evm');
            await updateTokenBalances();
        }

        // Connect Solana wallet (Phantom, etc.)
        async function connectSolanaWallet(wallet) {
            solanaWallet = wallet.provider;

            // Request connection
            const response = await wallet.provider.connect();
            connectedAddress = response.publicKey.toString();
            connectedWalletType = 'solana';
            console.log('Connected Solana address:', connectedAddress);

            // Initialize Solana connection
            const chainConfig = CHAIN_CONFIG[selectedChainKey] || CHAIN_CONFIG['SOLANA_DEVNET'];
            solanaConnection = new solanaWeb3.Connection(chainConfig.rpcUrls[0], 'confirmed');

            updateWalletUI(connectedAddress, 'solana');
            await updateTokenBalances();
        }

        // Update wallet UI after connection
        function updateWalletUI(address, walletType) {
            document.getElementById('connectWalletBtn').classList.add('hidden');
            document.getElementById('walletInfo').classList.remove('hidden');
            document.getElementById('customerSection').classList.remove('hidden');
            // paymentSection is now visible by default, no need to show it

            // Format address display
            const shortAddress = address.slice(0, 6) + '...' + address.slice(-4);
            document.getElementById('walletAddress').textContent = shortAddress;

            // Store wallet type for later
            window.connectedWalletType = walletType;

            // Enable pay button if chain is also selected
            updatePayButtonState();
        }

        // Update pay button state - enabled only when wallet connected AND chain selected
        function updatePayButtonState() {
            const payBtn = document.getElementById('payBtn');
            const canPay = connectedAddress && selectedChainKey;
            payBtn.disabled = !canPay;
        }

        // Parse URL parameters to get product info
        async function loadProductInfo() {
            const urlParams = new URLSearchParams(window.location.search);
            currentProduct = {
                id: urlParams.get('productId'),
                name: urlParams.get('productName'),
                price: parseFloat(urlParams.get('price')),
                merchantId: urlParams.get('merchantId') || null,
                enabledChains: urlParams.get('chains') ? urlParams.get('chains').split(',') : null // Specific chains to show
            };

            if (!currentProduct.id || !currentProduct.name || !currentProduct.price) {
                showError('Invalid product data. Please start from the store.');
                setTimeout(() => goBack(), 3000);
                return;
            }

            // Update UI with product info
            document.getElementById('productName').textContent = currentProduct.name;
            document.getElementById('productPrice').textContent = `$${currentProduct.price} (${currentProduct.price} USDC)`;

            console.log('Product loaded:', currentProduct);
            if (currentProduct.enabledChains) {
                console.log('Enabled chains from URL:', currentProduct.enabledChains);
            }

            // Fetch merchant's enabled chains
            await loadMerchantChains();
        }

        // Fetch merchant's configured wallets and render chain options
        async function loadMerchantChains() {
            const chainOptionsContainer = document.getElementById('chainOptions');

            if (!currentProduct.merchantId) {
                // No merchant ID - show default testnet chains
                console.log('No merchant ID, showing default testnet chains');
                let defaultChains = Object.keys(CHAIN_CONFIG)
                    .filter(key => CHAIN_CONFIG[key].network === 'testnet');

                // Filter by URL param if provided
                if (currentProduct.enabledChains) {
                    defaultChains = defaultChains.filter(key => currentProduct.enabledChains.includes(key));
                }

                merchantChains = defaultChains.map(key => ({ chain: key, address: null }));
                renderChainOptions();
                return;
            }

            try {
                console.log('Fetching merchant wallets for:', currentProduct.merchantId);
                const response = await fetch(`/api/merchant-profile?id=${currentProduct.merchantId}`);

                if (!response.ok) {
                    throw new Error('Failed to fetch merchant profile');
                }

                const merchantData = await response.json();
                console.log('Merchant data:', merchantData);

                if (merchantData.wallets && merchantData.wallets.length > 0) {
                    // Only show chains the merchant has configured
                    merchantChains = merchantData.wallets
                        .filter(w => w.isActive && CHAIN_CONFIG[w.chain])
                        .map(w => ({
                            chain: w.chain,
                            address: w.address
                        }));

                    // Further filter by URL-specified chains if provided
                    if (currentProduct.enabledChains && currentProduct.enabledChains.length > 0) {
                        merchantChains = merchantChains.filter(mc =>
                            currentProduct.enabledChains.includes(mc.chain)
                        );
                        console.log('Filtered to specified chains:', currentProduct.enabledChains);
                    }

                    if (merchantChains.length === 0) {
                        chainOptionsContainer.innerHTML = `
                            <div class="text-center py-4 text-red-600 font-bold">
                                No payment chains available for this checkout.
                            </div>
                        `;
                        return;
                    }
                } else {
                    // No wallets configured - show message
                    chainOptionsContainer.innerHTML = `
                        <div class="text-center py-4 text-red-600 font-bold">
                            Merchant has not configured any payment wallets yet.
                        </div>
                    `;
                    return;
                }

                renderChainOptions();
            } catch (error) {
                console.error('Error loading merchant chains:', error);
                // Fallback to testnet chains
                merchantChains = Object.keys(CHAIN_CONFIG)
                    .filter(key => CHAIN_CONFIG[key].network === 'testnet')
                    .map(key => ({ chain: key, address: null }));
                renderChainOptions();
            }
        }

        // Render chain options based on merchant's configured wallets
        function renderChainOptions() {
            const container = document.getElementById('chainOptions');

            if (merchantChains.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-4 text-gray-500">
                        No payment chains available
                    </div>
                `;
                return;
            }

            container.innerHTML = merchantChains.map((mc, index) => {
                const config = CHAIN_CONFIG[mc.chain];
                if (!config) return '';

                const isFirst = index === 0;
                const chainType = config.type || 'evm';
                const tokens = config.tokens || {};
                const tokenList = Object.entries(tokens);

                // Build token balance display
                const tokenBalances = tokenList.map(([symbol, tokenConfig]) =>
                    `<span id="balance_${mc.chain}_${symbol}" class="text-gray-400">-- ${symbol}</span>`
                ).join(' | ');

                // Build token radio buttons for selection
                const tokenOptions = tokenList.map(([symbol, tokenConfig], tokenIndex) =>
                    `<label class="inline-flex items-center mr-4 cursor-pointer">
                        <input type="radio" name="token_${mc.chain}" value="${symbol}"
                               class="w-4 h-4 mr-1" ${tokenIndex === 0 ? 'checked' : ''}
                               onchange="selectToken('${mc.chain}', '${symbol}')">
                        <span class="text-sm text-black font-medium">${symbol}</span>
                    </label>`
                ).join('');

                return `
                    <div class="chain-option border-4 border-black p-4 ${isFirst ? 'bg-blue-50' : 'bg-white'} hover:bg-gray-100 cursor-pointer"
                         onclick="selectChain('${mc.chain}')">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center space-x-3">
                                <input type="radio" name="chain" value="${mc.chain}" class="w-5 h-5" ${isFirst ? 'checked' : ''}>
                                <div>
                                    <div class="font-bold text-black">${config.chainName.toUpperCase()}</div>
                                    <div class="text-xs text-gray-600">${config.description || config.network} ${chainType === 'solana' ? '(Solana)' : '(EVM)'}</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="text-xs text-gray-500 font-bold">YOUR BALANCE</div>
                                <div class="text-sm font-mono">${tokenBalances}</div>
                            </div>
                        </div>
                        <div class="mt-3 pt-3 border-t-2 border-gray-200">
                            <div class="text-xs text-gray-600 font-bold mb-2">PAY WITH:</div>
                            <div class="flex flex-wrap">${tokenOptions}</div>
                        </div>
                    </div>
                `;
            }).join('');

            // Add event listeners to chain radios
            setupChainListeners();

            // Select first chain by default
            if (merchantChains.length > 0) {
                selectChain(merchantChains[0].chain);
            }
        }

        // Select a chain
        function selectChain(chainKey) {
            selectedChainKey = chainKey;

            // Update radio button
            const radio = document.querySelector(`input[name="chain"][value="${chainKey}"]`);
            if (radio) radio.checked = true;

            // Update visual selection
            document.querySelectorAll('.chain-option').forEach(el => {
                el.classList.remove('bg-blue-50');
                el.classList.add('bg-white');
            });
            const selectedEl = document.querySelector(`input[name="chain"][value="${chainKey}"]`)?.closest('.chain-option');
            if (selectedEl) {
                selectedEl.classList.remove('bg-white');
                selectedEl.classList.add('bg-blue-50');
            }

            // Update pay button state (enabled only if wallet also connected)
            updatePayButtonState();

            // Select first token of this chain by default
            const config = CHAIN_CONFIG[chainKey];
            if (config && config.tokens) {
                const firstToken = Object.keys(config.tokens)[0];
                selectToken(chainKey, firstToken);
            }

            console.log('Selected chain:', chainKey);
        }

        // Select a token
        function selectToken(chainKey, tokenSymbol) {
            selectedToken = tokenSymbol;

            // Update radio button
            const radio = document.querySelector(`input[name="token_${chainKey}"][value="${tokenSymbol}"]`);
            if (radio) radio.checked = true;

            // Update pay button text
            const payBtn = document.getElementById('payBtn');
            if (payBtn) {
                payBtn.textContent = `PAY WITH ${tokenSymbol}`;
            }

            console.log('Selected token:', tokenSymbol, 'on', chainKey);
        }

        // Setup chain radio button listeners
        function setupChainListeners() {
            const chainRadios = document.querySelectorAll('input[name="chain"]');
            chainRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    selectChain(e.target.value);
                });
            });
        }

        // Go back to store
        function goBack() {
            window.location.href = '/public/store.html';
        }

        // Connect Wallet - shows modal for wallet selection
        function connectWallet() {
            console.log('Opening wallet selection modal...');
            showWalletModal();
        }

        // Disconnect wallet
        async function disconnectWallet() {
            console.log('Disconnecting wallet...');

            // Clear any cached permissions (EVM)
            if (selectedWalletProvider) {
                try {
                    await selectedWalletProvider.request({
                        method: "wallet_revokePermissions",
                        params: [{ eth_accounts: {} }]
                    });
                } catch (err) {
                    console.log('Error revoking EVM permissions (may not be supported):', err);
                }
            }

            // Disconnect Solana wallet
            if (solanaWallet) {
                try {
                    await solanaWallet.disconnect();
                } catch (err) {
                    console.log('Error disconnecting Solana wallet:', err);
                }
            }

            // Clear local state
            provider = null;
            signer = null;
            connectedAddress = null;
            connectedWalletType = null;
            selectedWalletProvider = null;
            solanaConnection = null;
            solanaWallet = null;

            // Update UI
            document.getElementById('connectWalletBtn').classList.remove('hidden');
            document.getElementById('walletInfo').classList.add('hidden');
            document.getElementById('customerSection').classList.add('hidden');
            // Keep paymentSection visible so user can select chain before reconnecting

            // Update pay button state
            updatePayButtonState();

            showSuccess('Wallet disconnected. You can now connect a different wallet.');
        }

        // Update token balances on all merchant's enabled chains
        async function updateTokenBalances() {
            if (!connectedAddress || !connectedWalletType) return;

            console.log('Checking token balances for:', connectedAddress, '(wallet type:', connectedWalletType + ')');

            // Only check chains that match the connected wallet type
            for (const mc of merchantChains) {
                const chainConfig = CHAIN_CONFIG[mc.chain];
                if (!chainConfig) continue;

                // Skip chains that don't match connected wallet type
                const chainType = chainConfig.type || 'evm';
                if (chainType !== connectedWalletType) {
                    console.log(`Skipping ${mc.chain} - chain type ${chainType} doesn't match wallet type ${connectedWalletType}`);
                    continue;
                }

                await checkAllTokensOnChain(mc.chain);
            }
        }

        // Alias for backwards compatibility
        async function updateUSDCBalance() {
            return updateTokenBalances();
        }

        // Check all token balances on a specific chain
        async function checkAllTokensOnChain(chainKey) {
            const config = CHAIN_CONFIG[chainKey];
            if (!config || !config.tokens) return;

            console.log(`Checking ${config.chainName} balances...`);

            for (const [tokenSymbol, tokenConfig] of Object.entries(config.tokens)) {
                if (config.type === 'solana') {
                    await checkSolanaTokenBalance(chainKey, tokenSymbol, tokenConfig);
                } else {
                    await checkEVMTokenBalance(chainKey, tokenSymbol, tokenConfig);
                }
            }
        }

        // Check EVM token balance
        async function checkEVMTokenBalance(chainKey, tokenSymbol, tokenConfig) {
            try {
                const config = CHAIN_CONFIG[chainKey];
                const chainProvider = new ethers.JsonRpcProvider(config.rpcUrls[0]);
                const tokenContract = new ethers.Contract(tokenConfig.address, ERC20_ABI, chainProvider);

                const balance = await tokenContract.balanceOf(connectedAddress);
                const formattedBalance = ethers.formatUnits(balance, tokenConfig.decimals);

                updateTokenBalanceUI(chainKey, tokenSymbol, formattedBalance);
                console.log(`${config.chainName} ${tokenSymbol}: ${formattedBalance}`);
            } catch (error) {
                console.error(`Error checking ${chainKey} ${tokenSymbol}:`, error);
                updateTokenBalanceUI(chainKey, tokenSymbol, null);
            }
        }

        // Check Solana SPL token balance
        async function checkSolanaTokenBalance(chainKey, tokenSymbol, tokenConfig) {
            try {
                const config = CHAIN_CONFIG[chainKey];

                // Initialize connection if not already done
                if (!solanaConnection) {
                    solanaConnection = new solanaWeb3.Connection(config.rpcUrls[0], 'confirmed');
                }

                const ownerPubkey = new solanaWeb3.PublicKey(connectedAddress);
                const mintPubkey = new solanaWeb3.PublicKey(tokenConfig.address);

                // Get associated token account
                const tokenAccounts = await solanaConnection.getParsedTokenAccountsByOwner(
                    ownerPubkey,
                    { mint: mintPubkey }
                );

                let balance = 0;
                if (tokenAccounts.value.length > 0) {
                    balance = tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount || 0;
                }

                updateTokenBalanceUI(chainKey, tokenSymbol, balance.toString());
                console.log(`${config.chainName} ${tokenSymbol}: ${balance}`);
            } catch (error) {
                console.error(`Error checking ${chainKey} ${tokenSymbol}:`, error);
                updateTokenBalanceUI(chainKey, tokenSymbol, null);
            }
        }

        // Update UI with token balance
        function updateTokenBalanceUI(chainKey, tokenSymbol, balance) {
            const balanceElement = document.getElementById(`balance_${chainKey}_${tokenSymbol}`);
            if (!balanceElement) return;

            if (balance === null) {
                balanceElement.textContent = `-- ${tokenSymbol}`;
                balanceElement.classList.add('text-gray-400');
                balanceElement.classList.remove('text-green-600');
            } else {
                const formatted = parseFloat(balance).toFixed(2);
                balanceElement.textContent = `${formatted} ${tokenSymbol}`;

                if (parseFloat(balance) > 0) {
                    balanceElement.classList.add('text-green-600');
                    balanceElement.classList.remove('text-gray-400');
                } else {
                    balanceElement.classList.add('text-gray-400');
                    balanceElement.classList.remove('text-green-600');
                }
            }
        }

        // Create order and initiate payment
        async function initiatePayment() {
            if (!connectedAddress || !currentProduct) {
                showError('Please connect wallet first');
                return;
            }

            // Validate customer email
            const customerEmail = document.getElementById('customerEmail').value.trim();
            const customerName = document.getElementById('customerName').value.trim();
            
            if (!customerEmail) {
                showError('Please enter your email address');
                document.getElementById('customerEmail').focus();
                return;
            }
            
            // Basic email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(customerEmail)) {
                showError('Please enter a valid email address');
                document.getElementById('customerEmail').focus();
                return;
            }

            const selectedChain = document.querySelector('input[name="chain"]:checked');
            if (!selectedChain) {
                showError('Please select a payment chain');
                return;
            }

            try {
                showTxStatus('Creating order...');

                let orderData;
                const chainConfig = CHAIN_CONFIG[selectedChain.value];
                const selectedChainData = merchantChains.find(mc => mc.chain === selectedChain.value);
                const tokenConfig = chainConfig.tokens[selectedToken];

                // Try API first for database persistence
                console.log('Attempting to create order via API...');
                console.log('Product:', currentProduct);
                console.log('Chain:', selectedChain.value);
                console.log('Token:', selectedToken);
                console.log('Payment Address:', selectedChainData?.address);
                
                try {
                    const apiUrl = '/api/v1/orders';
                    console.log('Calling API:', apiUrl);

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            amount: currentProduct.price,
                            chain: selectedChain.value,
                            token: selectedToken, // Which stablecoin to pay with
                            productId: currentProduct.id,
                            productName: currentProduct.name,
                            customerEmail: customerEmail,
                            customerName: customerName || null,
                            merchantId: currentProduct.merchantId || 'DEMO',
                            paymentAddress: selectedChainData?.address || null // Merchant's wallet for this chain
                        })
                    });
                    
                    console.log('API Response status:', response.status);
                    console.log('API Response headers:', response.headers);
                    
                    if (response.ok) {
                        const apiResponse = await response.json();
                        // Extract the order from the API response wrapper
                        orderData = apiResponse.order || apiResponse;
                        // Add chain config addresses for the selected token
                        orderData.usdcAddress = tokenConfig.address; // Token contract address
                        orderData.paymentAddress = orderData.paymentAddress || selectedChainData?.address;
                        console.log('[SUCCESS] Order created via API:', orderData);
                    } else {
                        const errorText = await response.text();
                        console.error('[ERROR] API Error Response:', errorText);
                        throw new Error('API returned error: ' + response.status);
                    }
                } catch (apiError) {
                    console.error('[ERROR] API Error details:', apiError);
                    console.log('[WARNING] Using localStorage fallback');
                    // Fallback to localStorage
                    const mockOrderId = 'order_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    orderData = {
                        id: mockOrderId,
                        orderId: mockOrderId,
                        amount: currentProduct.price,
                        chain: selectedChain.value,
                        token: selectedToken,
                        paymentAddress: selectedChainData?.address,
                        usdcAddress: tokenConfig.address, // Token contract address
                        productId: currentProduct.id,
                        productName: currentProduct.name,
                        createdAt: new Date().toISOString(),
                        expiresAt: new Date(Date.now() + 30 * 60 * 1000).toISOString(),
                        status: 'PENDING',
                        txHash: null,
                        fromAddress: null
                    };
                    
                    // Store in localStorage for demo
                    localStorage.setItem('currentOrder', JSON.stringify(orderData));
                    
                    // Add to demoOrders array
                    const demoOrders = JSON.parse(localStorage.getItem('demoOrders') || '[]');
                    demoOrders.push(orderData);
                    localStorage.setItem('demoOrders', JSON.stringify(demoOrders));
                }

                console.log('Order created:', orderData);

                // Now process payment - route based on chain type
                const chainType = chainConfig.type || 'evm';
                if (chainType === 'solana') {
                    await processSolanaPayment(orderData, selectedChain.value);
                } else {
                    await processEVMPayment(orderData, selectedChain.value);
                }

            } catch (error) {
                console.error('Payment error:', error);
                showError('Payment failed: ' + error.message);
                hideTxStatus();
            }
        }

        async function processEVMPayment(order, chainKey) {
            const chainConfig = CHAIN_CONFIG[chainKey];
            const targetChainId = parseInt(chainConfig.chainId, 16);

            // ALWAYS switch to correct chain FIRST before any contract calls
            showTxStatus('Checking network...');

            try {
                const currentChainId = await provider.getNetwork().then(n => Number(n.chainId));
                console.log('Current chain:', currentChainId, 'Target chain:', targetChainId);

                const walletProvider = selectedWalletProvider || window.ethereum;

                if (currentChainId !== targetChainId) {
                    showTxStatus(`Switching to ${chainConfig.chainName}...`);

                    try {
                        await walletProvider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: chainConfig.chainId }],
                        });
                    } catch (switchError) {
                        // Chain not added, add it
                        if (switchError.code === 4902 || switchError.code === -32603) {
                            showTxStatus(`Adding ${chainConfig.chainName} to wallet...`);
                            await walletProvider.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: chainConfig.chainId,
                                    chainName: chainConfig.chainName,
                                    rpcUrls: chainConfig.rpcUrls,
                                    blockExplorerUrls: chainConfig.blockExplorerUrls,
                                    nativeCurrency: chainConfig.nativeCurrency
                                }],
                            });
                        } else if (switchError.code === 4001) {
                            throw new Error('You rejected the network switch. Please switch to ' + chainConfig.chainName + ' to continue.');
                        } else {
                            throw switchError;
                        }
                    }

                    // Wait a moment for the chain switch to complete
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            } catch (networkError) {
                console.error('Network switch error:', networkError);
                throw new Error('Failed to switch network: ' + networkError.message);
            }

            // Reinitialize provider and signer AFTER chain switch
            const activeProvider = selectedWalletProvider || window.ethereum;
            provider = new ethers.BrowserProvider(activeProvider);
            signer = await provider.getSigner();

            // Verify we're on the correct chain now
            const verifyChainId = await provider.getNetwork().then(n => Number(n.chainId));
            if (verifyChainId !== targetChainId) {
                throw new Error(`Please switch to ${chainConfig.chainName} in your wallet to complete this payment.`);
            }

            console.log('Successfully on chain:', verifyChainId);

            // Validate addresses
            if (!order.usdcAddress || !order.paymentAddress) {
                throw new Error('Missing contract or payment addresses');
            }

            console.log('USDC Address:', order.usdcAddress);
            console.log('Payment Address:', order.paymentAddress);

            // Get the selected token configuration
            const tokenConfig = chainConfig.tokens[selectedToken];
            if (!tokenConfig) {
                throw new Error(`Token ${selectedToken} not configured for ${chainConfig.chainName}`);
            }

            // Create token contract (now on correct chain)
            const tokenContract = new ethers.Contract(
                tokenConfig.address,
                ERC20_ABI,
                signer
            );

            // Get decimals - this should work now that we're on the right chain
            showTxStatus(`Preparing ${selectedToken} transfer...`);
            const decimals = await tokenContract.decimals();
            const amount = ethers.parseUnits(order.amount.toString(), decimals);

            showTxStatus('Preparing transaction...');

            // Send token transfer
            showTxStatus('Please confirm transaction in your wallet...');
            const tx = await tokenContract.transfer(order.paymentAddress, amount);
            
            showTxStatus('Transaction sent! Waiting for confirmation...');
            console.log('Transaction hash:', tx.hash);

            // Show explorer link
            const explorerUrl = `${chainConfig.blockExplorerUrls[0]}/tx/${tx.hash}`;
            document.getElementById('txLink').href = explorerUrl;
            document.getElementById('txLink').classList.remove('hidden');

            // Update order with transaction hash (demo mode - localStorage)
            try {
                const storedOrder = JSON.parse(localStorage.getItem('currentOrder'));
                if (storedOrder) {
                    storedOrder.txHash = tx.hash;
                    storedOrder.fromAddress = connectedAddress;
                    storedOrder.status = 'PAID';
                    localStorage.setItem('currentOrder', JSON.stringify(storedOrder));
                    
                    // Update demo orders list (only if using localStorage fallback)
                    const demoOrders = JSON.parse(localStorage.getItem('demoOrders') || '[]');
                    const orderIndex = demoOrders.findIndex(o => o.id === order.id);
                    if (orderIndex >= 0) {
                        demoOrders[orderIndex].status = 'PAID';
                        demoOrders[orderIndex].txHash = tx.hash;
                        demoOrders[orderIndex].fromAddress = connectedAddress;
                        localStorage.setItem('demoOrders', JSON.stringify(demoOrders));
                        console.log('Updated localStorage order with tx hash:', tx.hash);
                    }
                    // No error if not found - it's probably in the database instead
                }
            } catch (err) {
                console.error('Failed to update order with tx hash:', err);
            }

            // Wait for confirmation
            const receipt = await tx.wait();
            console.log('Transaction confirmed:', receipt);

            // Update order status to confirmed in database
            console.log('Confirming order in database...');
            console.log('Order ID:', order.id);
            console.log('TX Hash:', tx.hash);

            try {
                const confirmUrl = `/api/v1/orders/${order.id}/confirm`;
                console.log('Calling confirm API:', confirmUrl);

                const confirmResponse = await fetch(confirmUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        orderId: order.id,
                        txHash: tx.hash,
                        fromAddress: connectedAddress,
                        blockNumber: receipt.blockNumber.toString(),
                        confirmations: receipt.confirmations
                    })
                });

                console.log('Confirm API Response status:', confirmResponse.status);

                if (confirmResponse.ok) {
                    const confirmData = await confirmResponse.json();
                    console.log('[SUCCESS] Order confirmed in database:', confirmData);
                } else {
                    const errorText = await confirmResponse.text();
                    console.error('[ERROR] Confirm API Error:', errorText);
                }
            } catch (err) {
                console.error('[ERROR] Failed to confirm order in database:', err);
            }

            // Show the success screen
            showPaymentSuccess(currentProduct, chainKey, explorerUrl);
        }

        // Process Solana SPL token payment
        async function processSolanaPayment(order, chainKey) {
            const chainConfig = CHAIN_CONFIG[chainKey];

            if (!solanaWallet || !connectedAddress) {
                throw new Error('Solana wallet not connected');
            }

            // Get the selected token configuration
            const tokenConfig = chainConfig.tokens[selectedToken];
            if (!tokenConfig) {
                throw new Error(`Token ${selectedToken} not configured for ${chainConfig.chainName}`);
            }

            showTxStatus(`Preparing ${selectedToken} transfer on Solana...`);

            try {
                // Initialize connection if needed
                if (!solanaConnection) {
                    solanaConnection = new solanaWeb3.Connection(chainConfig.rpcUrls[0], 'confirmed');
                }

                const fromPubkey = new solanaWeb3.PublicKey(connectedAddress);
                const toPubkey = new solanaWeb3.PublicKey(order.paymentAddress);
                const mintPubkey = new solanaWeb3.PublicKey(tokenConfig.address);

                // Get or derive associated token accounts
                const fromTokenAccount = await solanaConnection.getParsedTokenAccountsByOwner(
                    fromPubkey,
                    { mint: mintPubkey }
                );

                if (fromTokenAccount.value.length === 0) {
                    throw new Error(`No ${selectedToken} token account found. Please ensure you have ${selectedToken} in your wallet.`);
                }

                const fromTokenAddress = fromTokenAccount.value[0].pubkey;

                // Check if recipient has a token account
                const toTokenAccount = await solanaConnection.getParsedTokenAccountsByOwner(
                    toPubkey,
                    { mint: mintPubkey }
                );

                let toTokenAddress;
                const transaction = new solanaWeb3.Transaction();

                if (toTokenAccount.value.length === 0) {
                    // Need to create associated token account for recipient
                    // This is a simplified approach - in production you'd use @solana/spl-token
                    showTxStatus('Creating recipient token account...');

                    // Get associated token address using a simpler approach
                    // For now, we'll require the recipient to have an existing token account
                    throw new Error('Recipient does not have a token account for this token. Please contact merchant.');
                } else {
                    toTokenAddress = toTokenAccount.value[0].pubkey;
                }

                // Calculate amount in token base units
                const amount = Math.floor(parseFloat(order.amount) * Math.pow(10, tokenConfig.decimals));

                showTxStatus('Please confirm transaction in your wallet...');

                // Create transfer instruction
                // Since we don't have full SPL token library, we'll use a raw transaction
                // This requires the @solana/spl-token library which is loaded
                const transferInstruction = splToken.createTransferInstruction(
                    fromTokenAddress,
                    toTokenAddress,
                    fromPubkey,
                    amount
                );

                transaction.add(transferInstruction);

                // Get latest blockhash
                const { blockhash, lastValidBlockHeight } = await solanaConnection.getLatestBlockhash();
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = fromPubkey;

                // Sign and send transaction via wallet
                const signedTransaction = await solanaWallet.signTransaction(transaction);
                const txHash = await solanaConnection.sendRawTransaction(signedTransaction.serialize());

                showTxStatus('Transaction sent! Waiting for confirmation...');
                console.log('Solana transaction hash:', txHash);

                // Build explorer URL
                const clusterParam = chainKey === 'SOLANA_DEVNET' ? '?cluster=devnet' : '';
                const explorerUrl = `${chainConfig.blockExplorerUrls[0]}/tx/${txHash}${clusterParam}`;

                document.getElementById('txLink').href = explorerUrl;
                document.getElementById('txLink').classList.remove('hidden');

                // Wait for confirmation
                const confirmation = await solanaConnection.confirmTransaction({
                    signature: txHash,
                    blockhash: blockhash,
                    lastValidBlockHeight: lastValidBlockHeight
                });

                if (confirmation.value.err) {
                    throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
                }

                console.log('Solana transaction confirmed');

                // Update order in database
                try {
                    const confirmUrl = `/api/v1/orders/${order.id}/confirm`;
                    const confirmResponse = await fetch(confirmUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            orderId: order.id,
                            txHash: txHash,
                            fromAddress: connectedAddress,
                            blockNumber: '0', // Solana uses slots, not block numbers
                            confirmations: 1
                        })
                    });

                    if (confirmResponse.ok) {
                        console.log('[SUCCESS] Solana order confirmed in database');
                    }
                } catch (err) {
                    console.error('[ERROR] Failed to confirm Solana order:', err);
                }

                // Show success screen
                showPaymentSuccess(currentProduct, chainKey, explorerUrl);

            } catch (error) {
                console.error('Solana payment error:', error);
                throw error;
            }
        }

        // Show full-page payment success screen
        function showPaymentSuccess(product, chainKey, explorerUrl) {
            // Hide all other sections
            document.getElementById('productSummary').classList.add('hidden');
            document.getElementById('walletSection').classList.add('hidden');
            document.getElementById('customerSection').classList.add('hidden');
            document.getElementById('paymentSection').classList.add('hidden');
            document.getElementById('errorMessage').classList.add('hidden');
            document.getElementById('successMessage').classList.add('hidden');

            // Populate success screen details
            document.getElementById('successProductName').textContent = product.name;
            document.getElementById('successAmount').textContent = `$${product.price} ${selectedToken}`;
            document.getElementById('successChain').textContent = CHAIN_CONFIG[chainKey]?.chainName || chainKey;
            document.getElementById('successTxLink').href = explorerUrl;

            // Show success screen
            document.getElementById('paymentSuccessScreen').classList.remove('hidden');

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Buy again - reload the same product
        function buyAgain() {
            // Reset UI
            document.getElementById('paymentSuccessScreen').classList.add('hidden');
            document.getElementById('productSummary').classList.remove('hidden');
            document.getElementById('walletSection').classList.remove('hidden');
            document.getElementById('paymentSection').classList.remove('hidden');

            // Reset wallet connection UI
            document.getElementById('connectWalletBtn').classList.remove('hidden');
            document.getElementById('walletInfo').classList.add('hidden');
            document.getElementById('customerSection').classList.add('hidden');

            // Clear form
            document.getElementById('customerEmail').value = '';
            document.getElementById('customerName').value = '';

            // Uncheck chain selection and reset token
            document.querySelectorAll('input[name="chain"]').forEach(r => r.checked = false);
            document.getElementById('payBtn').disabled = true;
            document.getElementById('payBtn').textContent = 'PAY WITH USDC';
            selectedToken = 'USDC';
            selectedChainKey = null;

            // Hide tx status
            hideTxStatus();
            document.getElementById('txLink').classList.add('hidden');

            // Disconnect wallet so user can reconnect
            provider = null;
            signer = null;
            connectedAddress = null;
            selectedWalletProvider = null;
            solanaConnection = null;
            solanaWallet = null;
            window.connectedWalletType = null;

            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // UI Helper functions
        function showError(message) {
            hideMessages();
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.querySelector('p').textContent = message;
            errorDiv.classList.remove('hidden');
        }

        function showSuccess(message) {
            hideMessages();
            const successDiv = document.getElementById('successMessage');
            successDiv.querySelector('p').textContent = message;
            successDiv.classList.remove('hidden');
        }

        function hideMessages() {
            document.getElementById('errorMessage').classList.add('hidden');
            document.getElementById('successMessage').classList.add('hidden');
        }

        function showTxStatus(message) {
            document.getElementById('txStatus').classList.remove('hidden');
            document.getElementById('txMessage').textContent = message;
        }

        function hideTxStatus() {
            document.getElementById('txStatus').classList.add('hidden');
        }

        // Listen for account changes
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', async (accounts) => {
                if (accounts.length === 0) {
                    disconnectWallet();
                } else if (connectedAddress) {
                    // Only update if already connected - don't re-open modal
                    connectedAddress = accounts[0];
                    document.getElementById('walletAddress').textContent =
                        connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
                    await updateUSDCBalance();
                    console.log('Account changed to:', connectedAddress);
                }
            });

            window.ethereum.on('chainChanged', () => {
                updateUSDCBalance();
            });
        }

        // Add event listeners when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Crypto payment page loaded');
            
            // Load product info first
            loadProductInfo();
            
            // Connect wallet button
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                connectBtn.addEventListener('click', connectWallet);
            }
            
            // Disconnect wallet button
            const disconnectBtn = document.getElementById('disconnectBtn');
            if (disconnectBtn) {
                disconnectBtn.addEventListener('click', disconnectWallet);
            }
            
            // Back button
            const backBtn = document.getElementById('backBtn');
            if (backBtn) {
                backBtn.addEventListener('click', goBack);
            }
            
            // Pay button
            const payBtn = document.getElementById('payBtn');
            if (payBtn) {
                payBtn.addEventListener('click', initiatePayment);
            }

            // Chain selection is handled by setupChainListeners() called from renderChainOptions()
        });

        // i18n functionality
        let currentLang = localStorage.getItem('preferredLanguage') || 'en';
        let translations = {};

        async function loadTranslations(lang) {
            try {
                const response = await fetch(`./locales/crypto-pay-${lang}.json`);
                translations = await response.json();
                applyTranslations();
            } catch (error) {
                console.error('Failed to load translations:', error);
            }
        }

        function applyTranslations() {
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                const keys = key.split('.');
                let value = translations;

                for (const k of keys) {
                    value = value[k];
                    if (!value) break;
                }

                if (value) {
                    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                        element.placeholder = value;
                    } else {
                        element.textContent = value;
                    }
                }
            });
        }

        // Language selector
        document.getElementById('languageSelector').addEventListener('change', (e) => {
            currentLang = e.target.value;
            localStorage.setItem('preferredLanguage', currentLang);
            loadTranslations(currentLang);
        });

        // Set initial language
        document.getElementById('languageSelector').value = currentLang;
        loadTranslations(currentLang);

        // Night mode toggle
        const nightModeToggle = document.getElementById('nightModeToggle');
        const nightIcon = document.querySelector('.night-icon');

        // Check for saved night mode preference
        if (localStorage.getItem('nightMode') === 'true') {
            document.body.classList.add('night-mode');
            const currentLang = localStorage.getItem('language') || 'en';
            fetch(`/locales/${currentLang}.json`)
                .then(res => res.json())
                .then(translations => {
                    nightIcon.textContent = translations.nav.day;
                    nightIcon.setAttribute('data-i18n', 'nav.day');
                });
        }

        nightModeToggle.addEventListener('click', () => {
            document.body.classList.toggle('night-mode');
            const isNightMode = document.body.classList.contains('night-mode');
            localStorage.setItem('nightMode', isNightMode);

            // Update translation
            const currentLang = localStorage.getItem('language') || 'en';
            fetch(`/locales/${currentLang}.json`)
                .then(res => res.json())
                .then(translations => {
                    nightIcon.textContent = isNightMode ? translations.nav.day : translations.nav.night;
                    nightIcon.setAttribute('data-i18n', isNightMode ? 'nav.day' : 'nav.night');
                });
        });
    </script>
</body>
</html>
